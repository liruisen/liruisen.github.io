{"meta":{"title":"Blog Sweets","subtitle":null,"description":"liruisen'Blog","author":"liruisen","url":"https://liruisen.github.io"},"pages":[{"title":"文章分类","date":"2017-05-27T05:47:40.000Z","updated":"2019-05-20T13:49:55.301Z","comments":false,"path":"tags/index.html","permalink":"https://liruisen.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-03T11:39:03.000Z","updated":"2019-05-20T13:49:55.301Z","comments":false,"path":"categories/index.html","permalink":"https://liruisen.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"恢复HEXO","slug":"2019-05-21 恢复Hexo","date":"2019-05-21T03:43:04.000Z","updated":"2019-05-21T05:26:34.858Z","comments":true,"path":"2019/05/21/2019-05-21 恢复Hexo/","link":"","permalink":"https://liruisen.github.io/2019/05/21/2019-05-21 恢复Hexo/","excerpt":"","text":"恢复HEXO 从GitHub上下载下来源文件 在文件夹内启用 cmd 输入 npm i hexo 执行 hexo clean hexo g hexo s 即可正常显示并恢复","categories":[{"name":"hexo教程","slug":"hexo教程","permalink":"https://liruisen.github.io/categories/hexo教程/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://liruisen.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://liruisen.github.io/tags/Github/"}]},{"title":"Webpack使用","slug":"2019-4-1  Webpack使用","date":"2019-04-01T01:20:04.000Z","updated":"2019-07-27T15:04:26.612Z","comments":true,"path":"2019/04/01/2019-4-1  Webpack使用/","link":"","permalink":"https://liruisen.github.io/2019/04/01/2019-4-1  Webpack使用/","excerpt":"","text":"Webpack4.X使用基本配置创建文件夹创建一个根文件夹和一个 dist 子文件夹一个名为 src子文件，在src子文件夹下创建一个.html文件和一个.js入口文件。 根文件夹 dist文件夹 src文件夹 index.html main.js 注意： src文件夹是我们的工程文件夹，我们所用的文件都要在这个文件夹里。 dist文件夹是我们最后打包输出的文件夹。（也可以不用建，webpack会自动帮我们创建） 初始化在终端中运行命令 1npm init -y 进行文件夹的初始化，然后会出现我们的package.json文件。 安装插件在本地下载 webpack,webpack-cli,webpack-dev-server，这三个包 运行的命令： 1cnpm i webpack webpack-cli webpack-dev-server -D 设置快捷启动命令在 package.json 文件的 scripts 对象里，添加 1\"start\":\"webpack --config webpack.config.js\" 这样就可以直接在终端中使用命令 npm start 运行。 webpack 会默认在你的根目录下找 webpack.config.js 文件，所以我们可以把命令简写成 “start” : “webpack” 创建配置文件在根目录下新建配置文件 webpack.config.js 12345678910const path = require('path') // 引用node包里的path工具module.exports = &#123; mode:'development',// 设置打包方式为开发者模式，production为生产者模式 entry:'./src/index.js',// 配置入口文件 output:&#123; //配置出口文件 filename:'bundle.js', //配置打包后的文件名，前面可加hash值：[hash:8]-bundle.js path:path.join(__dirname,'./dist')// 配置打包后文件的输出路径 &#125;&#125; 运行 npm start ，webpack 就会为我们自动打包，并自动创建 dist 文件夹，生成bundle.js 注意：如果此时，我们在html文件里通过script标签引入bundle.js话，我们就已经可以看到效果了，当然我们需要在js文件里，写上一句console.log(&quot;Hello webpack&quot;)。如果能输出，这也证明，到现在为止，我们的使用是没有错误的。 配置loader配置css-loader加载样式 在html文件中写一个&lt;div class=&quot;box&quot;&gt;hello world&lt;/div&gt;【主要是为了看效果，写啥都行】 在src文件夹下，新建一个style.css文件，里面写上你喜欢的box的样式。 在js文件中引入.css文件，import &#39;./style.css&#39;（此时打包绝对失败） 安装两个包style-loader,css-loader 运行的命令：cnpm i style-loader css-loader -D 在webpack.config.js文件中配置规则： 12345module:&#123; rules:[ //这里匹配的是规则 &#123;test:/\\.css$/,use:['style-loader','css-loader']&#125; //这是一个正则表达式：匹配到以.css结尾的文件，以这两个loader来解析 ] &#125; 注意：这个 module对象 和前面的 配置出口文件 的对象是平级的。 此时，运行npm start打包后，即可在页面中看到效果。 配置file-loader加载图片 如果我们直接在.html文件里，使用src=“”引入文件，可能就会出现文件无法打包解析的情况。 如果我们在css文件里，通过background:url()，引入图片，打包会直接报错，此时我们就需要这个file-loader。 运行命令： 1cnpm i file-loader -D 在webpack.config.js里的rules里配置规则： 1&#123;test:/\\.(png|svg|jpg|gif|webp)$/,use:'file-loader'&#125;// 匹配到图片文件，以file-loader来解析。 此时，运行npm run build即可发现图片显示出来了。 使用Webpack-dev-server自动更新前面说基本配置的时候，已经下载过webpack-dev-server这个包了，所以这里直接去配置。 首先在webpack.config.js文件里，新建一个devServer:{}对象。 注意：这个对象，也是直属于module.exports = {}里。 123456devServer:&#123; contentBase:&apos;./src&apos;,// 自动打包显示的文件路径，会自动找到src文件夹下的index.html文件 hot:true,// 启用热更新 port:3000, // 启用的端口号 open:true // 自动打开浏览器&#125; 配置 package.json 文件，在这个文件的 scripts 对象里写上 1\"build\":\"webpack-dev-server\" 此时，我们就不需要再去运行npm start打包了，直接运行npm run build启动webpack-dev-server即可。甚至于，我们可以直接把start后面的webpack替换成我们的webpack-dev-server 当然这个时候，我们是可以直接去运行webpack-dev-server了，但是启动成功后，当你在浏览器，访问http://localhost:3000的话，你会发现没有效果，连绿色的样式效果都没了。 问题就出在引用bundle.js的路径上. 验证方法： 我们把本地dist里的bundle.js删除，你会发现页面还是会显示，还是报的一样的错误。 所以，我们要更改引入的bundle.js的路径，webpack-dev-server在运行的时候，其实帮我们把bundle.js托管到了内存里，既然这样，我们运行的时候，直接引入即可，不用搞那么多复杂的路径。 1&lt;script src=\"bundle.js\"&gt;&lt;/script&gt; 这样，我们在运行的时候，就会发现样式回来了。 不用停止webpack-dev-server，直接去更改样式，保存之后在浏览器里刷新，你就会发现，样式也自动帮我们打包了 顺带提一句，要想停止webpack-dev-server，使用ctrl+c，然后输入Y即可。 使用html-webpack-plugin插件 要使用html-webpack-plugin插件，首先要先下载插件。 运行命令：cnpm i html-webpack-plugin -D 接着在webpack.config.js里进行插件的配置。 首先要引入插件： 1const HtmlWebpackPlugin = require('html-webpack-plugin') 接着，配置插件信息： 123456plugins:[ new HtmlWebpackPlugin(&#123; filename:'index.html',// 插件打包后输出的文件名 template:'./src/index.html' // 插件打包文件的路径 &#125;)] 注意：plugins数组也是直属于module.exports = {} 这样我们在运行npm run build时，就可以看到效果。其实这个插件是把我们的html页面也托管到了内存里，实现页面的自动实时刷新。 如果我们查看网页源代码，你就会发现，它帮我们自动引入了bundle.js文件。 ​ 此时我们在引入bundle.js就显得多余了，直接删除在.html文件里引入的即可。 使用babel转换ES6语法 要使用babel，首先要下载三个包，分别是babel-loader,@babel/core,@babel/preset-env 运行命令： 1cnpm i babel-loader @babel/core @babel/preset-env -D 提示：我们下载的是7.X的版本，babel-loader是 8.X命令中，千万不要写成 babel-core，babel-preset-env 这样的写法，是babel6.X的版本，和 webpack4.X 以及 babel-loader8.X 版本不符。 下载完成之后，配置我们的webpack-config.js文件： 在我们的rules数组规则里添加： 12345678910&#123; test: /\\.js$/, exclude: /node_modules/, //由于babel转换比较消耗性能，并且node_modules的文件比较多，也并不需要转换，所以要排除 use: [&#123; loader: 'babel-loader', options: &#123; presets:['@babel/preset-env'] //可以根据配置的目标浏览器或者运行环境来自动将ES2015+的代码转换为es5。 &#125; &#125;]// 这里配置的是babel转换ES6语法的规则&#125; 配置完成之后，我们测试一下:在.html文件里写上一个按钮: 1&lt;input type=\"button\" value=\"点击\" id=\"ipt\"&gt; 在我们的.js文件里，用一下箭头函数： 12var ipt = document.getElementById('ipt');ipt.onclick = () =&gt; alert(123); npm run build运行之后，打包成功，点击按钮，会发现弹窗也正常显示。 小结到这里，我们的webpack基本配置就算结束了，但是这样，你有可能也是只知道，webpack怎么做成可以让页面自动刷新，自动帮我们打包，解析ES6语法等等。建议大家，可以在读完这篇博客后，找一个自己写的小项目，比如一个简单的登录注册，去实地的测试一下webpack打包。当然webpack还有许许多多其他的地方，大家可以去看看webpack官网。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://liruisen.github.io/tags/webpack/"},{"name":"前端模块化","slug":"前端模块化","permalink":"https://liruisen.github.io/tags/前端模块化/"}]},{"title":"Nginx使用","slug":"2019-03-29 Nginx","date":"2019-03-29T05:12:55.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2019/03/29/2019-03-29 Nginx/","link":"","permalink":"https://liruisen.github.io/2019/03/29/2019-03-29 Nginx/","excerpt":"为了学习下分布式技术，先学习下 Nginx 反向代理服务器，在学习过程中，顺便还巩固了计算机系统的一些知识，同时，网上关于在 Linux 上配置 Nginx 的教程已经很多了，奈何本人对 Linux 并不是很熟悉，同时现在写的网站大多还是发布在 IIS 上面的，因此本教程主要讲解在 Windows 下配置 Nginx 反向代理服务器。","text":"为了学习下分布式技术，先学习下 Nginx 反向代理服务器，在学习过程中，顺便还巩固了计算机系统的一些知识，同时，网上关于在 Linux 上配置 Nginx 的教程已经很多了，奈何本人对 Linux 并不是很熟悉，同时现在写的网站大多还是发布在 IIS 上面的，因此本教程主要讲解在 Windows 下配置 Nginx 反向代理服务器。 Windows下配置 Nginx 反向代理服务器什么是代理？在学习 Nginx 前，先补充下代理服务器的概念： 代理服务器：一般指的是局域网内部的机器通过代理服务器发送请求到互联网上的服务器，代理服务器一般作用在客户端。应用方面比如：科学上网工具、Nginx。 完整的代理请求流程：客户端首先与代理服务器创建连接，然后根据代理服务器所使用的代理协议请求对目标服务器创建连接或者获得目标服务器的指定资源。代理服务器位于客户端和 Web 服务器之间，扮演中间人的角色，HTTP 的代理服务器既是 Web 服务器又是 Web 客户端，而代理服务器则是介于客户端与 Web 服务器中间的另一台服务器。有了代理服务器之后，客户端发过来的请求不再直接发向 Web 服务器，而是发向了代理服务器，由代理服务器发出请求，取回请求资源后，返回给客户端。 image 正向代理服务器： 位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指向原始服务器，然后代理向原始服务器转交请求并将获取到的内容返回给客户端。客户端必须进行一些特别的设置才能使用正向代理。 反向代理服务器： 在服务端接收客户端的请求，然后把请求分发给具体的服务器进行处理，再将服务器的响应结果返回给客户端。Nginx 就是其中一种反向代理服务器软件。 NginxNginx 是俄罗斯 Igor Sysoev 开发的一款高性能的HTTP和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器，Nginx 本身就可以托管网站，进行HTTP服务处理，也可以作为反向代理服务器使用。 Nginx特点 跨平台：Nginx 可以在大多数 Unix 内核的系统中编译运行，也有 Windows 的移植版本。 配置简单：配置风格和程序开发相近 高并发、非阻塞：复制数据时，磁盘 I/O 的第一阶段是非阻塞的。官方测试能够支撑5万并发连接（实际生产环境中能跑到 2万~3万 并发连接数） 事件驱动：通信机制采用 epoll 模型，支撑更大的并发连接 除此之外，Nginx 还有其他业务上的优势： Nginx 代理和后端 Web 服务器间无需长连接 接收用户请求是异步的，即先将用户的请求全部接收下来，再一次性发送后端 Web 服务器，极大减轻后端Web 服务器的压力 发送响应报文时，一遍接收来自后端 Web 服务器的数据，一边发送个客户端 网络依赖性低。Nginx 对网络的依赖程度非常低，从理论上来说，只要能够 Ping 通就可以实施负载均衡，而且可以有效区分内网和外网流量。 支持服务器检测。Nginx 能够根据应用服务器处理页面返回的状态码，超时信息等检测服务器是否出现故障，并及时返回错误的请求，重新提交到其他节点上。 Nginx事件处理机制通信机制采用epoll模型，支持更大的并发连接。 master/worker 结构：一个 master 进程，生成多个 worker 进程 内存消耗小：并发处理大并发的请求，内存消耗非常小。在3万并发连接下，开启的1个 Nginx 进程才消耗150MB 内存（15MB*10=150MB） 成本低：Nginx 作为开源软件，可以免费使用，而硬件负载均衡交换机则需要十多万甚至几十万人民币 内置的健康检查功能：如果 Nginx Proxy 后端的某台 Web 服务器宕机了，就不会影响前端访问 节省带宽：支持GZIP压缩，可以添加浏览器本地缓存的Header头。 稳定性高：用于反向代理，宕机的概率微乎其微。 Nginx 内部模型 Nginx是以多进程的方式来工作的。当然 nginx 也是支持多线程的方式的,仅仅是我们主流的方式还是多进程的方式，也是nginx的默认方式。 nginx 採用多进程的方式有诸多优点。 nginx 在启动后，会有一个master进程和多个 worker 进程。master 进程主要用来管理 worker 进程，包括：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的执行状态,当 worker 进程退出后(异常情况下)，会自己主动又一次启动新的 worker 进程。而主要的网络事件。则是放在 worker 进程中来处理了 。多个 worker 进程之间是对等的，他们同等竞争来自 client 的请求。各进程互相之间是独立的 。一个请求，仅仅可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其他进程的请求。 worker 进程的个数是能够设置的，一般我们会设置与机器 cpu 核数一致，这里面的原因与 nginx 的进程模型以及事件处理模型是分不开的 。 Master 接收到信号以后如何进行处理（./nginx -s reload ）? 首先 master 进程在接到信号后，会先又一次载入配置文件。然后再启动新的进程。并向全部老的进程发送信号，告诉他们能够光荣退休了。 新的进程在启动后，就開始接收新的请求，而老的进程在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的全部未处理完的请求处理完毕后，再退出 . worker 进程又是如何处理请求的呢？我们前面有提到。worker 进程之间是平等的。每一个进程，处理请求的机会也是一样的。当我们提供 80 port 的 http 服务时。一个连接请求过来，每一个进程都有可能处理这个连接，怎么做到的呢？首先，每一个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面。先建立好须要 listen 的 socket 之后。然后再 fork 出多个 worker 进程，这样每一个 worker 进程都能够去 accept 这个 socket (当然不是同一个 socket ，仅仅是每一个进程的这个 socket 会监控在同一个 ip 地址与 port，这个在网络协议里面是同意的)。一般来说。当一个连接进来后。全部在 accept 在这个 socket 上面的进程。都会收到通知。而仅仅有一个进程能够 accept 这个连接，其他的则 accept 失败，这是所谓的惊群现象。 当然，nginx 也不会视而不见，所以 nginx 提供了一个 accept_mutex 这个东西，从名字上。我们能够看这是一个加在 accept 上的一把共享锁。有了这把锁之后，同一时刻，就仅仅会有一个进程在 accpet 连接，这样就不会有惊群问题了。accept_mutex 是一个可控选项，我们能够显示地关掉。默认是打开的。当一个 worker 进程在 accept 这个连接之后，就開始读取请求。解析请求。处理请求，产生数据后，再返回给 client，最后才断开连接，这样一个完整的请求就是这种了。我们能够看到，一个请求。全然由 worker 进程来处理。并且仅仅在一个 worker 进程中处理。 nginx 采用这种进程模型有什么优点呢？採用独立的进程，能够让互相之间不会影响，一个进程退出后，其他进程还在工作，服务不会中断，master 进程则非常快又一次启动新的 worker 进程。当然，worker 进程的异常退出。肯定是程序有 bug 了，异常退出。会导致当前 worker 上的全部请求失败，只是不会影响到全部请求，所以减少了风险。当然，优点还有非常多，大家能够慢慢体会。 有人可能要问了。nginx 採用多 worker 的方式来处理请求，每一个 worker 里面仅仅有一个主线程，那能够处理的并发数非常有限啊。多少个 worker 就能处理多少个并发。何来高并发呢？非也，这就是 nginx 的高明之处，nginx 採用了异步非堵塞的方式来处理请求。也就是说，nginx 是能够同一时候处理成千上万个请求的 .对于 IISserve r每一个请求会独占一个工作线程。当并发数上到几千时，就同一时候有几千的线程在处理请求了。 这对操作系统来说。是个不小的挑战，线程带来的内存占用非常大。线程的上下文切换带来的 cpu 开销非常大。自然性能就上不去了。而这些开销全然是没有意义的。 我们之前说过，推荐设置 worker 的个数为 cpu 的核数，在这里就非常 easy 理解了，很多其他的 worker 数，仅仅会导致进程来竞争 cpu 资源了，从而带来不必要的上下文切换。 并且，nginx 为了更好的利用多核特性，提供了 cpu 亲缘性的绑定选项。我们能够将某一个进程绑定在某一个核上。这样就不会由于进程的切换带来 cache 的失效。 Nginx应用场景负载均衡技术在现有网络结构智商提供了一种廉价、有效、透明的方法来扩展网络设备和服务器的带宽 、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。它有两方面的含义：首先，大量并发的访问或数据流量分担到多台节点设备上分别处理，减少用户等待相应的时间；其次，单个负载均衡的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后将结果汇总，返回给用户，系统处理能力得到大幅度提高。 Nginx的使用本文只讲解 Windows 版本的 Nginx，Linux 上的 Nginx 以后再讲 到官方网站下载 Windows 版本。下载地址 解压后，文件结构如下 修改配置文件 。打开目录 Conf，找到 nginx 核心的配置文件 nginx.conf 进行修改。 启动服务：直接运行 nginx.exe 即可。 停止服务： 启动任务管理器直接关闭进程 在 CMD 中，进入 nginx.exe 所在目录，输入 nginx -s stop 重新加载配置： 重启 nginx.exe 在 CMD 中，进入 nginx.exe 所在目录，输入 nginx -s reload Nginx的常见配置常见配置 Nginx集群案例最后一步，通过一个 Demo 来演示使用 Nginx+IIS 服务器来搭建服务器集群 为了演示，创建了3个 Web 项目，然后分别部署在三台IIS服务器上，当然这个 Demo 并未做详细的业务与逻辑，只以站点的内容让其稍微有点不同以区分。而生产环境则是把相同的 Web 项目部署在不同的IIS服务器上面。 创建项目 新建一个空的 MVC 项目 添加控制器 Home 添加 Index 视图 1234@&#123; ViewBag.Title = \"Index\"&#125;&lt;h2&gt;这是第1个网站&lt;/h2&gt; 发布站点1 将发布好的站点中的View\\Home\\Index.cshtml内容修改为： 1234@&#123; ViewBag.Title = \"Index\"&#125;&lt;h2&gt;这是第2个网站&lt;/h2&gt; 获得第二个站点，并发布 继续第5步，修改内容为： 1234@&#123; ViewBag.Title = \"Index\"&#125;&lt;h2&gt;这是第3个网站&lt;/h2&gt; 获得第三个站点，并发布 修改 Nginx 的配置文件 nginx.conf 在 http 节点上添加代码如下： 1234567upstream netittest.com&#123; #服务器集群名字 server www.barteam.cn:8085 weight=1; server superforest.cn:8085 weight=1; server 127.0.0.1:8087 weight=1; server 127.0.0.1:8089 weight=1;&#125; 修改 http 节点上的 server 节点、 location 节点 1234567891011 server &#123; listen 8088; #监听端口 server_name superforest.cn；#你服务器的节点，如果是本地的话为127.0.0.1 location / &#123; #root html; #index index.html index.htm; proxy_pass http://netittest.com; proxy_redirect default; ·············&#125; 启动 nginx 服务，以管理员身份，运行 CMD 窗口，进入 nginx 所在目录，启动 nginx.exe 1C:\\Program Files (x86)\\nginx-1.14.2&gt;nginx.exe 在浏览器输入你上面 server 中配置的 server_name 和 listen（nginx 配置文件中配置的服务器监听终结点），然后刷新浏览器，结果如下： image 请注意，浏览器地址框一直未变。 其实现原理如下图所示 image 这个 Demo 只是为了简单演示下关于通过 Nginx 搭建集群的效果，如果换到生产环境的话，需要配置的就不止上面这些，关于其他详细的配置可以查看前文中的链接，或去百度查找其他博客。 参考资料 《ASP.NET MVC 企业级实战》 Nginx内部模型 Nginx常见配置","categories":[{"name":"分布式","slug":"分布式","permalink":"https://liruisen.github.io/categories/分布式/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://liruisen.github.io/tags/Windows/"},{"name":"Nginx","slug":"Nginx","permalink":"https://liruisen.github.io/tags/Nginx/"}]},{"title":"art-template 踩坑","slug":"2019-03-12 art-template","date":"2019-03-11T03:12:55.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2019/03/11/2019-03-12 art-template/","link":"","permalink":"https://liruisen.github.io/2019/03/11/2019-03-12 art-template/","excerpt":"项目需要使用 art-template 进行前端渲染，本想直接使用 Vue ，不过项目渲染不多，还是学习下 art-template吧，提前踩踩坑，避免用在项目上的时候出现问题。用的时候了解到 art-template 好像是腾讯团队开发维护的，感觉文档要糟糕，不出所料在文档上遇到一些问题。","text":"项目需要使用 art-template 进行前端渲染，本想直接使用 Vue ，不过项目渲染不多，还是学习下 art-template吧，提前踩踩坑，避免用在项目上的时候出现问题。用的时候了解到 art-template 好像是腾讯团队开发维护的，感觉文档要糟糕，不出所料在文档上遇到一些问题。 art-template使用笔记art-template 是前端的一个高性能 JavaScript 模板引擎，它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能。 通过下面一张图可以大致了解下 art-template 与其他方式渲染HTML页面的性能比较： 具体跟 Vue、React 这些前端主流框架比较的性能，官方并未给出数据，但是我认为只比较页面渲染能力的话，应该相差不多， Vue、React 是一整套的前端解决方案，而 art-template 只是一个 js模板引擎，二者定位和功能不同，不做详细比较，猜测 art-template 同样是使用虚拟 DOM 的方式进行页面渲染，否则能达到这样的性能，着实不容易。就学习而言，如果学习过 Vue、React，学这个非常简单，反过来学会 art-template 对学习 Vue、React也有一定帮助。 在网上查询资料的时候，发现 art-template 好像是腾讯团队开发开源的，了解到这个情况的时候，心中少不了吐槽，不可否认东西确实好用，但是架不住腾讯团队写的文档烂啊！！腾讯团队什么时候能在文档上面长点心，学学隔壁的阿里。废话不多说了，简单写下容易遇到的问题。 初始化问题关于 art-template 模板编写语法很简洁； template 对象的初始化也非常简单，只有两行代码， 模板编写： 12345678910111213141516171819&lt;script id=\"art-template\" type=\"text/html\"&gt;&lt;table&gt; /******/ &lt;tbody&gt; &#123;&#123;each classInfoList&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Teacher&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Remark&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"&#123;&#123;$value.Uri&#125;&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/script&gt; template对象初始化： 12var html = template(\"art-template\", datas);document.getElementById('app').innerHTML = html; &quot;art-template&quot; 是定义好的模板的 id datas 是需要渲染的数据 JS执行时间、顺序问题在网上找到的 Demo 大多都是在 js 里面写一个假数据，用定义好的数据去初始化 template 对象，例如： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;basic-demo&lt;/title&gt; &lt;script src=\"../dist/template.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script id=\"test\" type=\"text/html\"&gt; &#123;&#123;if isAdmin&#125;&#125; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &#123;&#123;each list as value i&#125;&#125; &lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &#123;&#123;/if&#125;&#125; &lt;/script&gt; &lt;script&gt; var data = &#123; title: '基本例子', isAdmin: true, list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他'] &#125;; var html = template('test', data); document.getElementById('content').innerHTML = html; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 因为以前主要使用 Vue ，Vue 是有动态渲染，但是忘记了这个并没有提到是动态渲染，同时项目开发时，数据大多通过 Ajax 从后台获取，因此在开始时，将 template 对象初始化放在了 ajax 回调函数外，因为 ajax 请求数据需要花费时间，同时js代码跟后台代码执行顺序不同，并不是按行数依次执行，所以前期导致一直渲染失败。应注意 js 代码执行顺序和执行时间的问题。 完整ajax代码如下： 1234567891011121314151617var datas = &#123; title: \"\", classInfoList: []&#125;$.ajax(&#123; type: \"GET\", dataType:\"JSON\", url: \"/ClassHandler.ashx\", success: function (data) &#123; //原生JS序列化JSOn //datas.classInfoList = JSON.parse(data).classInfoList; datas.classInfoList = data.classInfoList; datas.title =data.title; html = template(\"art-template\", datas); document.getElementById('app').innerHTML = html; &#125;&#125;) template数据初始化问题在上面也看到，序列化 template 对象一共传了两个参数，一个是模板的 Id，另外一个是数据。 但是这个数据有个一问题，如果返回回来的 JSON 数据是类似数组数据的话，是没有办法直接渲染的，如： 12345678910111213141516171819[&#123; \"Id\": 0, \"Name\": \"班级0\", \"Teacher\": \"教师0\", \"Remark\": \"这是班级0的简介\", \"Uri\": \"/deleteClass.ashx?id=0\"&#125;, &#123; \"Id\": 1, \"Name\": \"班级1\", \"Teacher\": \"教师1\", \"Remark\": \"这是班级1的简介\", \"Uri\": \"/deleteClass.ashx?id=1\"&#125;, &#123; \"Id\": 2, \"Name\": \"班级2\", \"Teacher\": \"教师2\", \"Remark\": \"这是班级2的简介\", \"Uri\": \"/deleteClass.ashx?id=2\"&#125;] 这个样子是没有办法直接进行渲染，需要对数据如上述代码块包装，才能正常渲染。 如果返回 JSON 数据为： 12345678910111213141516171819202122&#123; \"classInfoList\": [&#123; \"Id\": 0, \"Name\": \"班级0\", \"Teacher\": \"教师0\", \"Remark\": \"这是班级0的简介\", \"Uri\": \"/deleteClass.ashx?id=0\" &#125;, &#123; \"Id\": 1, \"Name\": \"班级1\", \"Teacher\": \"教师1\", \"Remark\": \"这是班级1的简介\", \"Uri\": \"/deleteClass.ashx?id=1\" &#125;, &#123; \"Id\": 2, \"Name\": \"班级2\", \"Teacher\": \"教师2\", \"Remark\": \"这是班级2的简介\", \"Uri\": \"/deleteClass.ashx?id=2\" &#125;], \"title\": \"软件学院班级列表\"&#125; 可以直接初始化 template 对象，并进行渲染（模板不变） 1234567891011&lt;script&gt; $.ajax(&#123; type: \"GET\", dataType:\"JSON\", url: \"/ClassHandler.ashx\", success: function (data) &#123; html = template(\"art-template\", data); document.getElementById('app').innerHTML = html; &#125; &#125;)&lt;/script&gt; template 对象初始化需注意地方API：template(filename, content) 根据模板名渲染模板。 参数： {string} filename {Object,string} content 返回值： 如果 content 为 Object，则渲染模板并返回 string 如果 content 为 string，则编译模板并返回 function 浏览器版本无法加载外部文件，filename 为存放模板的元素 id 因为渲染的时候，数据大多从后台获取，后台返回的数据可能为字符串或JSON，如果第二个参数（content）传进来的是字符串的话，没有报错，但是渲染会失败，渲染结果如下： image 因此，需注意 template 初始化赋值时，数据格式是否正确。 渲染问题each 循环渲染问题关于循环的语法，官方文档上写的很简洁： image 默认在遍历 target 时，有两个值，value和index，其中 value 是单个对象值，index 是下标。 根据文档所写，我把 123456789101112&#123;&#123;each classInfoList&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Teacher&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Remark&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;&#123;$value.Uri&#125;&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&#123;&#123;/each&#125;&#125; 修改为： 123456789101112&#123;&#123;each classInfoList val key&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;$key+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$val.Id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$val.Name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$val.Teacher&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$val.Remark&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;&#123;$val.Uri&#125;&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&#123;&#123;/each&#125;&#125; 浏览器在渲染的时候就报错了： image 至今不清楚，是我没领会文档说明，还是 art-template 团队忘了维护文档了。 结语本文只是 art-template js模板引擎的简单使用，还有其他几个接口、方式没有逐一介绍，在我看来这些已经能够满足基本的开发使用，至于更加复杂的渲染、渲染切换，Vue 比 art-template 省心。如有兴趣继续研究 art-template ，附上官方文档及参考博客链接。 参考文档： art-template 官方文档 art-template官方API文档 js模板引擎-art-template常用总结","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"art-template","slug":"art-template","permalink":"https://liruisen.github.io/tags/art-template/"},{"name":"JS引擎模板","slug":"JS引擎模板","permalink":"https://liruisen.github.io/tags/JS引擎模板/"}]},{"title":"问题与解决方案汇总（1）","slug":"2019-01-30 前端bootstrap表格与axios请求","date":"2019-01-30T08:58:13.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2019/01/30/2019-01-30 前端bootstrap表格与axios请求/","link":"","permalink":"https://liruisen.github.io/2019/01/30/2019-01-30 前端bootstrap表格与axios请求/","excerpt":"开发过程中少不了踩坑，记录下各个踩坑的详情，给自己带来便利的同时，也能给其他人提供或多或少的帮助，这就再好不过了。第一期有两个问题，分别是 Bootstrap 表格中插入按钮导致表格自适应失效 ，以及 axios.js 在 Vue.js 的搭配使用过程中的 this 无法指向 Vue 对象 。","text":"开发过程中少不了踩坑，记录下各个踩坑的详情，给自己带来便利的同时，也能给其他人提供或多或少的帮助，这就再好不过了。第一期有两个问题，分别是 Bootstrap 表格中插入按钮导致表格自适应失效 ，以及 axios.js 在 Vue.js 的搭配使用过程中的 this 无法指向 Vue 对象 。 问题1 ： Bootstrap 表格中插入按钮导致表格自适应失效问题描述：昨天在写前台的时候，把前台的表格使用了Bootstrap美化了一下，立刻漂亮了很多，然后随手将表格里面的两个 a 标签加上了btn btn-danger btn-sm 、btn btn-success btn-sm 两个类，效果增强了很多，如图： image 今天在写前台代码的时候，突然发现表格中的文字的行距不再居中对齐了，文本位置偏上。 image 思考过程： 应该不是什么太大的问题吧，去问下前端比较厉害的同学吧，发了信息，该过年了比较忙，没有来得及回复。 直接去调整表格里面文字的 lin-hight 吧，直接去浏览器定位到单元格的类，然后回编辑器进行修改。 解决问题的思路： 想如果适应到其他设备上，写固定值的行高会不会不合适？但是好像又没有什么好的解决方案，但是灵光一动想到（吃饱了以后想到），a 标签是行内元素，button 是块级元素，给 a 标签添加上 btn 类的时候，是否将 a 标签由行内元素转换成块级元素？实验后发现，想法正确。不添加 btn 类只是单独的 a 标签，这个时候表格的自适应还是有效的；将 a 标签换成 button 标签后，表单的自适应失效。 image 既然发现了问题所在，那就容易解决了，将添加过 btn btn-danger btn-sm 的 a 标签由块级元素重新转换成行内元素就行了。 考虑到其他地方添加 btn 类的内容不需要转换成行内元素，因此这里解决的办法是在内联样式表中添加上这样一行，或者是写一个类，只有下面一条样式，然后将这个类放在 class 属性的最后面。 12345678910.btn-sm&#123; display:inline; &#125;OR.ainline&#123; display:inline;&#125;&lt;a class=\"btn btn-success btn-sm ainline\" v-on:click=\"\"&gt;另一种方法&lt;/a&gt; 如果你有更好的解决方案，请一起沟通。 发现问题产生原因所在，和解决问题一样重要。 问题2：axios.js 在 Vue.js 的配合中的 this以前在使用 Vue 向后台发送 ajax 请求的时候，使用的是 vue-resource.js ，不过现在 Vue 已经停止更新 vue-resource ，转而建议使用 axios.js ，新手注定多踩坑。 问题描述：在 vue-resource 向后台发送 ajax 的时候，只需要简单的一行 js 代码就能搞定，当然 axios.js 也是很简单的一行就能搞定，但是问题出在了接收数据的环节。下面请看 vue-resource 的解决方案。 12345678910111213var user = new Vue(&#123;el: \"#app\",data: &#123; userListApiUrl: '/Home/UserList', jsondata: []&#125;,methods: &#123; getRequest: function () &#123; this.$http.get(this.userListApiUrl).then(function (res) &#123; this.jsondata = res.body; &#125;) &#125;&#125;) 其中，在 then(function (res){} 函数中，直接就能把从后台返回的数据赋值给 this.jsondata ，很简洁也很简单。 但是 axios 按照这个格式去写的话，也能拿到后台返回的数据，但是就是不能将返回的数据 赋值给 this.jsondata (axios 的语法不再前面添加 this) 12345678910111213var user = new Vue(&#123;el: \"#app\",data: &#123; userListApiUrl: '/Home/UserList', jsondata: []&#125;,methods: &#123; getRequest: function () &#123; axios.get(this.userListApiUrl).then(function (res) &#123; this.jsondata = res.data; &#125;) &#125;&#125;) 思考过程：出现这样的问题一直百思不得其解，难不成只能一直使用 vue-resource ？ 向困难低头不是我的作风。羊毛出在羊身上，从浏览器上寻找问题。 通过对 js 代码打断点发现了一个现象： image 这个 this 好像指向了 Window 对象，回头查看两段代码，发现了区别： 12345678// vue-resourcethis.$http.get(this.userListApiUrl).then(function (res) &#123; this.jsondata = res.body;&#125;)// axiosaxios.get(this.userListApiUrl).then(function (res) &#123; this.jsondata = res.data;&#125;) vue-resource 在使用前加了 this，根据代码所在的位置，可以判断出第一个和第二个 this 指向的对象都是 user 这个 Vue 对象，因此该段代码的作用域还是在new Vue() 中，这样的话里面的第三个 this 指向的也是 user 对象。 同时， vue-resource 能在前面添加 this 说明 vue-resource 集成在了 Vue 框架中，因此需要添加 this. 才能正常使用，但是在 axios 有没有集成到 Vue 框架中我并不知道啊（事后实验发现在 Vue 中通过 this 并不能访问到 axios 也可能是我的操作不对），官方的Demo就直接这样写了也没见加 this，因此在 axios 代码段中，第一个 this 因为作用域的原因，指向的是 user 这个 Vue 对象，但是里面的 this 因为没有集成到 Vue 同时 axios.js 是独立的 js 文件，作用域为顶级作用域，因此第二个 this 指向的是 Window 这个对象。 解决过程：既然发现问题出在哪里了，那就比较容易解决了，既然 axios 内部的作用域是顶级作用域，那么 user 对象就和其处在同一个作用域中了，修改后的代码如下： 12345678910111213var user = new Vue(&#123;el: \"#app\",data: &#123; userListApiUrl: '/Home/UserList', jsondata: []&#125;,methods: &#123; getRequest: function () &#123; axios.get(this.userListApiUrl).then(function (res) &#123; user.jsondata = res.data; &#125;) &#125;&#125;) 同时，根据 Vue 的生命周期钩子函数的执行顺序，在此位置访问 user 应该是没有问题的。 问题解决。 如果你有其他的看法，一起交流。 多看，多实践。","categories":[{"name":"问题与解决方案","slug":"问题与解决方案","permalink":"https://liruisen.github.io/categories/问题与解决方案/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://liruisen.github.io/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"https://liruisen.github.io/tags/axios/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://liruisen.github.io/tags/Bootstrap/"},{"name":"前端问题","slug":"前端问题","permalink":"https://liruisen.github.io/tags/前端问题/"}]},{"title":":Vue与其他操作DOM的第三方库搭配使用","slug":"2019-01-17 Vue与其他操作DOM的第三方库搭配使用","date":"2019-01-17T03:14:10.000Z","updated":"2019-06-21T08:35:50.321Z","comments":true,"path":"2019/01/17/2019-01-17 Vue与其他操作DOM的第三方库搭配使用/","link":"","permalink":"https://liruisen.github.io/2019/01/17/2019-01-17 Vue与其他操作DOM的第三方库搭配使用/","excerpt":"","text":"本次环境为直接引用 Vue.js（开发版） , 没有使用脚手架 Vue 的核心思想是数据驱动 DOM，也建议我们避免直接去进行 DOM 操作，但是在很多业务里，避免不了去使用一些第三方的库，比如 popper.js、swiper.js 等，这些基于原生 JavaScript 的库都有创建和更新及销毁的完整生命周期，如果与 Vue 搭配使用的话，不可避免的会出现直接操作 DOM 的现象，这个时候需要合理的利用一些 Vue 的机制 : $nextTick 使用场景先来看一个简单的demo 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;div id=\"div\" v-if=\"showDiv\"&gt;这是一段文本&lt;/div&gt; &lt;button @click=\"getText\"&gt;获取Div内容&lt;/button&gt;&lt;/div&gt;&lt;script&gt;var app=new Vue(&#123; el:\"#app\", data:&#123; showDiv:false &#125;, methods:&#123; getText:function()&#123; this.showDiv=true; var text=document.getElementById('div').innerHTML; console.log(text); &#125; &#125;&#125;)&lt;/script&gt; 很简单的一段代码：有一个 div ，默认使用 v-if 进行隐藏，点击按钮后，改变 v-if的值，将 div 的值显示出来，同时拿到这个值，输出到控制台上。 按照正常的思路，如果 v-if 的值是 false，直接去获取 div 的内容是获取不到的，因为此时 div 还未被创建，那么应该在点击按钮后，改变 v-if 的值为 true ，div 才会被创建，此时才能被获取到。 但是按照这种思路，控制台会抛出一个异常： Cannot read property &#39;innerHTML&#39; of null 意思是获取不到 div 元素。 异步更新队列按我们正常的思路来说上述代码应该是可以获取到 div 的，但是在实际运行过程中并未能获取到，这里面就涉及到 Vue 一个重要的概念：异步更新队列 Vue 在观察到数据变化时，并不是直接更新 DOM ，而是开启一个队列，并缓冲在同一事件循环过程中发生的所有数据改变，在缓冲时会去除重复数据，从而避免不必要的计算和 DOM 操作。然后，在下一个事件循环 tick 中，Vue 刷新队列并执行实际（已去重的）工作。举个例子来说，如果使用 for 循环来动态改变数据 100 次，其实 Vue 只会应用最后一次改变，如果没有这种机制的话，DOM 就要重绘 100 次，这是一个很大的开销。 关于队列，Vue 会根据当前浏览器环境优先使用 Promise.then 和 MutationObserver ，如果都不支持，就会使用 setTimeout 代替。 解决方法知道 Vue 异步更新 DOM 的原理后，上面的报错应该就很容易理解了。在执行 this.showDiv=true; 时，div 仍然没有被创建出来，直到下一个 Vue 事件循环时，才开始创建。 如果引用了其他的第三方库，需要立即创建、立即获取，这个时候就需要避开 Vue 的这种机制了，$nextTick 就是用来指导什么时候 DOM 更新完成的，所以上面的代码需要进行修改：123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;div id=\"div\" v-if=\"showDiv\"&gt;这是一段文本&lt;/div&gt; &lt;button @click=\"getText\"&gt;获取Div内容&lt;/button&gt;&lt;/div&gt;&lt;script&gt;var app=new Vue(&#123; el:\"#app\", data:&#123; showDiv:false &#125;, methods:&#123; getText:function()&#123; this.showDiv=true; //update begin this.$nextTick(function()&#123; var text=document.getElementById('div').innerHTML; console.log(text); &#125;) //update end &#125; &#125;&#125;)&lt;/script&gt; 这时再点击按钮，控制台就会打印出 div 的内容：这是一段文本 。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"},{"name":"Vue","slug":"前端/Vue","permalink":"https://liruisen.github.io/categories/前端/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://liruisen.github.io/tags/Vue/"}]},{"title":"GitHub：无限制的免费私人仓库","slug":"2019-01-08 GitHub私人仓库免费","date":"2019-01-07T08:58:13.000Z","updated":"2019-05-26T08:26:41.276Z","comments":true,"path":"2019/01/07/2019-01-08 GitHub私人仓库免费/","link":"","permalink":"https://liruisen.github.io/2019/01/07/2019-01-08 GitHub私人仓库免费/","excerpt":"","text":"新的GitHub：无限制的免费私人仓库 Github 2018年6月4日微软发布公告称，微软将以 75亿美元 的微软股票收购 GitHub ，因为过往业界对微软闭源的固有观念，使得业内并不看好 GitHub 被收购后的未来，以至于出现了一批把项目从 GitHub 迁移到其他平台的热点，但是微软已经不是十年前那个微软，如今 GitHub 也已不再是收购前的 GitHub 了。 GitHub 被收购前，国内拉取 GitHub 的仓库及推送 GitHub的仓库，速度基本上并不快，以百兆宽带来说，下行速度基本不超过 1Mb/s ，上行速度不超过 200kb/s ，收购后第一个可喜的变化就是国内地区的网络服务得到了极大的提升，上行和下行速度基本不会出现像百度网盘那样限速一样的现象，现在的速度很大都是基于带宽。 今天， GitHub 发了一篇博客，宣布了 GitHub 的又一改变：无限制的免费私有存储库。 每个存储库最多可以免费使用三个协作者，对于大部分只有自己进行代码提交的开发者来说，已经够用了！ 在此之前，如果想要使用 GitHub 的免费私人仓库，有两种途径，每月支付 $7 或认证为学生账户，对非学生群体的开发者来说，每月 7美刀 的价格并不是很亲民，同时国内其他代码托管平台提供的免费私人仓库服务，也给开发者提供了不同的选择。 今天 Github 的改变固然让开发者很是欣喜，不过这一改变也会挤压国内其他代码托管平台的生存空间，具体利弊因人而异，GitHub 后续如何，敬请期待。 Github该篇博客链接","categories":[{"name":"随笔","slug":"随笔","permalink":"https://liruisen.github.io/categories/随笔/"},{"name":"新闻","slug":"随笔/新闻","permalink":"https://liruisen.github.io/categories/随笔/新闻/"}],"tags":[{"name":"新闻","slug":"新闻","permalink":"https://liruisen.github.io/tags/新闻/"}]},{"title":"Hexo发布文章","slug":"2018-11-04 Hexo发布文章","date":"2018-11-04T06:43:04.000Z","updated":"2019-06-21T08:30:27.213Z","comments":true,"path":"2018/11/04/2018-11-04 Hexo发布文章/","link":"","permalink":"https://liruisen.github.io/2018/11/04/2018-11-04 Hexo发布文章/","excerpt":"","text":"前面咱们已经搭建好了Hexo博客，并成功发布到了Github上面，但是怎么才能把新写的文章发布上去呢？ 创建新文章方法1：进入你的博客目录，在 /source/_posts 文件夹下直接建立一个.md文件。 需要注意的是，文件内容的开头有固定的格式： 12345---title: Hexo发布文章date: 2018-11-03 19:52:39tags:Hexo--- title 是文章的标题 date 是文章的发布时间 tags 是文章的标签 后面写正文就可以了！ 方法2：进入博客目录，使用 Git Bash Here 命令窗口，或者 Windows 自带的 CMD 命令窗口，输入下面命令 1hexo new &quot;新建文章名称&quot; 这样就会在 /source/_posts 文件夹下，新建好一个 .md 文件，同时该文件中的头部信息 （title、data、tags）也会给你默认生成，后面接着写正文就可以了 。 发布文章新文章写好了，但是直接启动 hexo 博客或直接访问托管的 Github 平台的话，会发现并没有写好的文章，这是因为写好的文章现在并没有被 hexo引擎解析，同时也没有推送到 Github 上生成。 在该博客项目文件夹下进入命令行窗口 Git Bash Here 和 CMD 都可以。 输入命令： 12hexo generatehexo deploy hexo generate : 生成修改 hexo deploy ：将生成的修改部署到 Github 上 注意 部署到GitHub时，可能因为网速、被墙等原因，需要多次运行 hexo deploy ；有时候可以运行 hexo clean 后在运行上述代码。 .md 文件不要用记事本打开，建议使用具有 markdown语法的程序打开，比如：Typora 、subline text、notepad++ 等，也可以使用在线 markdown 编辑器 。","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://liruisen.github.io/categories/Hexo教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liruisen.github.io/tags/Hexo/"}]},{"title":"Hexo + Github pages搭建私人博客","slug":"2018-11-03 Hexo-Github-pages搭建私人博客","date":"2018-11-03T02:43:04.000Z","updated":"2019-06-21T08:29:53.687Z","comments":true,"path":"2018/11/03/2018-11-03 Hexo-Github-pages搭建私人博客/","link":"","permalink":"https://liruisen.github.io/2018/11/03/2018-11-03 Hexo-Github-pages搭建私人博客/","excerpt":"","text":"最近因为开始喜欢上使用 Markdown 语法来写博客，主要是因为现在各个博客网站对 Markdown 语法的支持越来越好了，本地写好一份文件，到各大博客复制粘贴即可，省去了博客搬家和手动调样式的烦恼，不会 Markdown 语法之前觉得这是什么沙雕玩意儿，现在是真香。 后来偶然想到，Github好像对 MarkDown 的支持也不错，我可以把写的博客源文件放在 Github 上备份一份啊！说干就干，专门开了一个仓库去保存博客源文件。前几篇写的挺舒服的，后来发现了一个问题，样式不好看，，，那啥，温饱之后开始追求精神需求量，哈哈哈哈哈，这个时候想起以前以为大佬好像提过可以在GIthub上写博客，我想，大佬的思想应该不会像我这么咸鱼吧，果不其然，还真让我找到了在 Github 上部署博客的方法，重点是还不用使用私人服务器和域名！！！真是发现新大陆了！！！撸起袖子加油干！！ 为什么要创建私人博客？我觉得现在身为互联网时代，有自己的个人网站其实就和有自己名片差不多，在这可以不断的记录自己的生活，总结知识，人生思考什么的。 同时对于码农来说，有自己的私人网站，有详细个人的博客，无疑会在自己工作或找工作的过程中提供帮助。 再者就是相对的自由了，现在市面上有很多的Blog系统，只要注册就可以直接在他们平台上生成一个自己的Blog，虽然省去了很多麻烦的步骤，但是命运赠送的一切欢愉，背后早已为其准备好了相应的痛苦：乱七八糟不停滚动的广告（CSXN）、简陋的UI（BoXYuan）……更不爽的就是，必须受到他们的限制与监管，只要擦边就删你文章。比如这样： 所以搞一个完全属于自己的网站，相对来说，没那么苦逼。 Github pages + Hexo 搭建博客什么是 Github pages ？详情点击 百度 ,那什么又是 Hexo 呢 ，详情还请点击 Hexo 。 安装 Git 和 Node.js因为最终我们是需要将博客部署在 Github 上面的（免费空间，不需要域名），所以需要安装 Git 工具，用于把我们的博客推送到 Github 上面（当然，只是为了保持与 Github 上面的仓库保持联系的话 Github Desktop 也是一个不错的工具，还免去了每次换电脑之后更换 shh 公钥的麻烦），因为 Hexo 是基于 Node.js 的，所以我们也需要安装 Node.js 。 Git下载地址 、 Node.js下载地址 关于二者的安装，一路 Next 下去就好了，建议装在 C 盘，环境类型相关的应用，装在其他盘里容易出问题。 检查安装是否成功 当Git 安装完毕后，Git Bash Here 和 Git GUI Here 应该已经集成在了鼠标右键中了。 右键进入 Git Bash Here进入命令行页面，输入 1node -v 如果可以看到 Node.js 的版本号，则证明已经安装成功。 安装 Hexo在任何地方，打开 Git Bash Here（Dos命令行也是可以的） 输入： 1npm install hexo-cli -g","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://liruisen.github.io/categories/Hexo教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liruisen.github.io/tags/Hexo/"}]},{"title":"复杂度分析","slug":"算法2：复杂度分析","date":"2018-09-26T13:58:13.000Z","updated":"2019-05-26T13:51:19.523Z","comments":true,"path":"2018/09/26/算法2：复杂度分析/","link":"","permalink":"https://liruisen.github.io/2018/09/26/算法2：复杂度分析/","excerpt":"数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这就要用到时间、空间复杂度分析了","text":"数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这就要用到时间、空间复杂度分析了 为什么需要复杂度分析？在代码写完后，我们把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？ 这种评估执行效率的方法是没有问题的，但是这种【事后统计法】具有很大的局限性。 测试结果非常依赖测试环境。 测试环境中硬件的不同会对测试结果有很大的影响。你在 i9 主机处理器上跑的代码和在树莓派上跑的代码，绝大部分结果应该都是前者更快。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等换到另一台机器上时，可能会有截然相反的结果。 测试结果受数据规模的影响很大 对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要更快！ 所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法，这就是时间、空间复杂度分析。 大 O 复杂度表示法算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？这里有段非常简单的代码，求 1,2,3…n 的累加和。现在来估算一下这段代码的执行时间吧 12345678int cal(int n) &#123; int sum = 0; int i = 1; for (; i &lt;= n; ++i) &#123; sum = sum + i; &#125; return sum;&#125; 假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time。可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。 按照这个分析思路，我们再来看这段代码。 1234567891011int cal(int n) &#123; int sum = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) &#123; j = 1; for (; j &lt;= n; ++j) &#123; sum = sum + i * j; &#125; &#125;&#125; 依旧假设每个语句的执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？ 第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n unit_time 的执行时间，第 7、8 行代码循环执行了 n2 遍，所以需要 2n2 unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n2+2n+3)*unit_time。 尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。 我们可以把这个规律总结成一个公式：T(n)=O(f(n) ) T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。 所以，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n2","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://liruisen.github.io/categories/算法和数据结构/"}],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://liruisen.github.io/tags/算法和数据结构/"}]},{"title":"对象分类","slug":"前端9. 2018-7-21 JS：对象分类","date":"2018-07-21T08:42:04.000Z","updated":"2019-07-26T02:31:41.095Z","comments":true,"path":"2018/07/21/前端9. 2018-7-21 JS：对象分类/","link":"","permalink":"https://liruisen.github.io/2018/07/21/前端9. 2018-7-21 JS：对象分类/","excerpt":"","text":"前面有两篇文章写了JavaScript对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的JavaScript对象。比如说，我们不论怎样编写代码，都没法绕开Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的length属性。并且，在浏览器环境中，也无法单纯依靠JavaScript代码实现div对象，只能靠document.createElement来创建。这也说明了JavaScript的对象机制并非简单的属性集合+原型。因此来总结下JS的对象及分类。 JavaScript中的对象分类可以把对象分成以下几类。 宿主对象（host Objects）：由JavaScript宿主环境提供的对象，它们的行为完全由宿主环境决定。 内置对象（Built-in Objects）：由JavaScript语言提供的对象。 固有对象（Intrinsic Objects ）：由标准规定，随着JavaScript运行时创建而自动创建的对象实例。 原生对象（Native Objects）：可以由用户通过Array、RegExp等内置构造器或者特殊语法创建的对象。 普通对象（Ordinary Objects）：由{}语法、Object构造器或者class关键字定义类创建的对象，它能够被原型继承。 宿主对象首先我们来看看宿主对象。 JavaScript宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。在浏览器环境中，我们都知道全局对象是window，window上又有很多属性，如document。实际上，这个全局对象window上的属性，一部分来自JavaScript语言，一部分来自浏览器环境。 JavaScript标准中规定了全局对象属性，w3c的各种标准中规定了Window对象的其它属性。宿主对象也分为固有的和用户可创建的两种，比如document.createElement就可以创建一些dom对象。 内置对象·固有对象固有对象是由标准规定，随着JavaScript运行时创建而自动创建的对象实例。固有对象在任何JS代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“类”其实就是固有对象的一种。 内置对象·原生对象我们把JavaScript中，能够通过语言本身的构造器创建的对象称作原生对象。在JavaScript标准中，提供了30多个构造器。按照不同应用场景，可以把原生对象分成了以下几个种类。 通过这些构造器，我们可以用new运算创建新的对象，所以我们把这些对象称作原生对象。几乎所有这些构造器的能力都是无法用纯JavaScript代码实现的，它们也无法用class/extend语法来继承。 这些构造器创建的对象多数使用了私有字段,例如： Error: [[ErrorData]] Boolean: [[BooleanData]] Number: [[NumberData]] Date: [[DateValue]] RegExp: [[RegExpMatcher]] Symbol: [[SymbolData]] Map: [[MapData]] 这些字段使得原型继承方法无法正常工作，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象” 函数对象与构造器对象前面介绍了对象的一般分类，在JavaScript中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。，JavaScript为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。 函数对象的定义是：具有[[call]]私有字段的对象，构造器对象的定义是：具有私有字段[[construct]]的对象。 JavaScript用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了“具有[[call]]私有字段的对象”，就可以被 JavaScript 函数调用语法支持。或者可以这样说，任何对象只需要实现[[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现[[construct]]，它就是一个构造器对象，可以作为构造器被调用。 对于为JavaScript提供运行环境的我们来说，只要字段符合，我们在上文中提到的宿主对象和内置对象（如Symbol函数）可以模拟函数和构造器。不过用function关键字创建的函数必定同时是函数和构造器，虽然它们表现出来的行为效果却并不相同。 对于宿主和内置对象来说，它们实现[[call]]（作为函数被调用）和[[construct]]（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串，见以下代码： 12console.log(new Date); // 1console.log(Date()) 而浏览器宿主环境中，提供的Image构造器，则根本不允许被作为函数调用。 12console.log(new Image); console.log(Image());//抛出错误 再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。 同时，在ES6之后 =&gt; 语法创建的函数仅仅是函数，它们无法被当作构造器使用，见以下代码： 1new (a =&gt; 0) // error 对于用户使用 function 语法或者Function构造器创建的对象来说，[[call]]和[[construct]]行为总是相似的，它们执行同一段代码。 12345function f()&#123; return 1;&#125;var v = f(); //把f作为函数调用var o = new f(); //把f作为构造器调用 因此大致可以认为，它们[[construct]]的执行过程如下： 以 Object.protoype 为原型创建一个新对象； 以新对象为 this，执行函数的[[call]]； 如果[[call]]的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。 这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么new创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。 123456789function cls()&#123; this.a = 100; return &#123; getValue:() =&gt; this.a &#125;&#125;var o = new cls;o.getValue(); //100//a在外面永远无法访问到 特殊行为的对象除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。 它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里我简单总结一下。 Array：Array的length属性根据最大的下标自动发生变化。 Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。 String：为了支持下标运算，String的正整数属性访问会去字符串里查找。 Arguments：arguments的非负整数型下标属性跟对应的变量联动。 模块的namespace对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于import吧。 类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。 bind后的function：跟原来的函数相关联。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://liruisen.github.io/tags/JS高级/"},{"name":"面对对象","slug":"面对对象","permalink":"https://liruisen.github.io/tags/面对对象/"}]},{"title":"原型与原型链","slug":"前端8. 2018-7-19 JS：原型与原型链","date":"2018-07-19T13:18:04.000Z","updated":"2019-07-26T02:31:34.460Z","comments":true,"path":"2018/07/19/前端8. 2018-7-19 JS：原型与原型链/","link":"","permalink":"https://liruisen.github.io/2018/07/19/前端8. 2018-7-19 JS：原型与原型链/","excerpt":"","text":"什么是原型？原型是顺应人类自然思维的产物。中文中有个成语叫做“照猫画虎”，这里的猫看起来就是虎的原型，所以，由此我们可以看出，用原型来描述对象的方法可以说是古已有之。 在JS的面对对象文章里面写过，在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象。最为成功的是使用“类”的方式来描述对象，这诞生了诸如 C++、Java等流行的编程语言。这个流派叫做基于类的编程语言。还有一种就是基于原型的编程语言，它们利用原型来描述对象。我们的JavaScript就是其中代表。 “基于类”的编程提倡使用一个关注分类和类之间关系开发模型。在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。与此相对，“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。 基于原型的面向对象系统通过“复制”的方式来创建新对象。基于原型和基于类都能够满足基本的复用和抽象需求，但是适用的场景不太相同。 原型系统的“复制操作”有两种实现思路： 一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用； 另一个是切实地复制对象，从此两个对象再无关联。 而JavaScript选择的是第一种：并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用； JavaScript的原型如果抛开JavaScript用于模拟Java类的复杂语法设施（如new、Function Object、函数的prototype属性等），原型系统可以说相当简单，可以用两条概括： 如果所有对象都有私有字段[[prototype]]，就是对象的原型； 读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。 这个模型在ES的各个历史版本中并没有很大改变，但从 ES6 以来，JavaScript提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为： Object.create 根据指定的原型创建新对象，原型可以是null； Object.getPrototypeOf 获得一个对象的原型； Object.setPrototypeOf 设置一个对象的原型。 利用这三个方法，可以完全抛开类的思维，利用原型来实现抽象和复用。如下面的代码展示了用原型来抽象猫和虎的例子。 123456789101112131415161718192021222324252627var cat = &#123; say()&#123; console.log(\"meow~\"); &#125;, jump()&#123; console.log(\"jump\"); &#125;&#125;var tiger = Object.create(cat, &#123; say:&#123; writable:true, configurable:true, enumerable:true, value:function()&#123; console.log(\"roar!\"); &#125; &#125;&#125;)var anotherCat = Object.create(cat);anotherCat.say();var anotherTiger = Object.create(tiger);anotherTiger.say(); 这段代码创建了一个“猫”对象，又根据猫做了一些修改创建了虎，之后我们完全可以用Object.create来创建另外的猫和虎对象，我们可以通过“原始猫对象”和“原始虎对象”来控制所有猫和虎的行为。 原型链关于JS的原型链，因为比较复杂加上JS语言的设计缺陷，就不详细描述了，具体可以看下面这张图，Person是自定义的对象，如果图看着不是太明白的话，可以写代码自定义个类，分别在浏览器中打印出原型、原型指向，再来看这个图。 早期版本中的类与原型在早期版本的JavaScript中，“类”的定义是一个私有属性 [[class]]，语言标准为内置类型诸如Number、String、Date等指定了[[class]]属性，以表示它们的类。语言使用者唯一可以访问[[class]]属性的方式是Object.prototype.toString。因此，在ES3和之前的版本，JS中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。 考虑到JavaScript语法中跟Java相似的部分，我们对类的讨论不能用“new运算是针对构造器对象，而不是类”来试图回避。所以，我们仍然要把new理解成JavaScript面向对象的一部分，那么new操作具体做了哪些事情？ new 运算接受一个构造器和一组调用参数，实际上做了几件事： 以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象； 将 this 和调用参数传给构造器，执行； 如果构造器返回的是对象，则返回，否则返回第一步创建的对象。 new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。 如下面代码，就展示了用构造器模拟类的两种方法: 123456789101112131415161718function c1()&#123; this.p1 = 1; this.p2 = function()&#123; console.log(this.p1); &#125;&#125; var o1 = new c1;o1.p2();//--------------------------function c2()&#123;&#125;c2.prototype.p1 = 1;c2.prototype.p2 = function()&#123; console.log(this.p1);&#125;var o2 = new c2;o2.p2(); 第一种方法是直接在构造器中修改this，给this添加属性。 第二种方法是修改构造器的prototype属性指向的对象，它是从这个构造器构造出来的所有对象的原型。 ES6 中的类好在ES6中加入了新特性class，new跟function搭配的怪异行为终于可以退休了（虽然运行时没有改变）,因此推荐使用ES6的语法来定义类，而令function回归原本的函数语义。 ES6中引入了class关键字，并且在标准中删除了所有[[class]]相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了JavaScript的官方编程范式。 类的基本写法如下： 1234567891011121314class Rectangle &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125; // Getter get area() &#123; return this.calcArea(); &#125; // Method calcArea() &#123; return this.height * this.width; &#125;&#125; 在现有的类语法中，getter/setter和method是兼容性最好的。 我们通过get/set关键字来创建getter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。 类的写法实际上也是由原型运行时来承载的，逻辑上JavaScript认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。 此外，最重要的是，类提供了继承能力。我们来看一下下面的代码。 12345678910111213141516171819202122class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name); // call the super class constructor and pass in the name parameter &#125; speak() &#123; console.log(this.name + ' barks.'); &#125;&#125;let d = new Dog('Mitzie');d.speak(); // Mitzie barks. 以上代码创造了Animal类，并且通过extends关键字让Dog继承了它，展示了最终调用子类的speak方法获取了父类的name。 比起早期的原型模拟方式，使用extends关键字自动设置了constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。 所以当我们使用类的思想来设计代码时，应该尽量使用class来声明类，而不是用旧语法，拿函数来模拟对象。一些激进的观点认为，class关键字和箭头运算符可以完全替代旧的function关键字，它更明确地区分了定义函数和定义类两种意图。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://liruisen.github.io/tags/JS高级/"},{"name":"面对对象","slug":"面对对象","permalink":"https://liruisen.github.io/tags/面对对象/"}]},{"title":"JS面对对象","slug":"前端7. 2018-6-20 JS：面对对象","date":"2018-06-20T07:30:04.000Z","updated":"2019-07-26T02:31:27.871Z","comments":true,"path":"2018/06/20/前端7. 2018-6-20 JS：面对对象/","link":"","permalink":"https://liruisen.github.io/2018/06/20/前端7. 2018-6-20 JS：面对对象/","excerpt":"","text":"前言在学习JS的面对对象的时候遇到一些疑惑，原因在于事先学习过C#的面对对象，因此在学习JS面对对象时候总喜欢把二者放在一起参考学习，因此经常会有疑惑，因为二者的面对对象相差很大。在网上找过很多资料看过很多观点之后，来写一写自己的理解吧。 很多人说JavaScript并非“面向对象的语言”，而是“基于对象的语言”，甚至东哥也是这样给我解惑的，但是我在问 “如何定义面向对象和基于对象” 时，东哥给我的回复我觉的并不能打消我的疑惑。 JavaScript标准对基于对象的定义的具体内容是：“语言和宿主的基础设施由对象来提供，并且JavaScript程序即是一系列互相通讯的对象集合”。我觉得这里并不是表达弱化的面向对象的意思，反而是表达对象对于语言的重要性。 什么是面对对象Object（对象）在英文中，是一切事物的总称，和面向对象编程的抽象思维有互通之处。 在《面向对象分析与设计》Grady Booch总结为，从人类的认知角度来说，对象应该是下列事物之一： 一个可以触摸或者可以看见的东西； 人的智力可以理解的东西； 可以指导思考或行动（进行想象或施加动作）的东西。 有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为常见的就是使用“类”的方式来描述对象，如Java、C#等。 JavaScript的面对对象而 JavaScript 早年却选择了一个更为冷门的方式：原型。同时因为一些公司政治原因，JavaScript推出之时受管理层之命被要求模仿Java，因此，JavaScript创始人Brendan Eich在“原型运行时”的基础上引入了new、this等语言特性，使之“看起来更像Java”。 在 ES6 之前，大量的 JavaScript 程序员试图在原型体系的基础上，把JavaScript变得更像是基于类的编程。 如果从运行时角度来谈论对象，就是在讨论JavaScript实际运行中的模型，这是由于任何代码执行都必定绕不开运行时的对象模型。幸运的是，从运行时的角度看，可以不必受到“基于类”的困扰，这是因为任何语言运行时类的概念都是被弱化的。 JavaScript 对象的特征如果看了Grandy Booch《面向对象分析与设计》从而了解了对象的本质特征，那么对象有一下几个特点： 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。 对象有状态：对象具有状态，同一对象可能处于不同状态之下。 对象具有行为：即对象的状态，可能因为它的行为产生变迁。 对象具有唯一标识性，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识。因此任何不同的JavaScript对象其实是互不相等的。如下面代码中，，o1和o2初看是两个一模一样的对象，但是打印出来的结果却是false。 123var o1 = &#123; a: 1 &#125;;var o2 = &#123; a: 1 &#125;;console.log(o1 == o2); // false 关于对象的第二个和第三个特征“状态和行为”，C# 中则称它们为“属性”和“方法”。但是，在 JavaScript中，将状态和行为统一抽象为“属性”，考虑到 JavaScript 中将函数设计成一种特殊对象，所以 JavaScript中的行为和状态都能用属性来抽象。 如下面这段代码，就展示了普通属性和函数作为属性的一个例子，其中o是对象，d是一个属性，而函数f也是一个属性，尽管写法不太相同，但是对JavaScript来说，d和f就是两个普通属性。 123456var o = &#123; d: 1, f() &#123; console.log(this.d); &#125; &#125;; 总结一句话来看，在JavaScript中，对象的状态和行为其实都被抽象为了属性，尽管设计思路和C#、Java有一定差别，但是二者都很好地表现了对象的基本特征：标识性、状态和行为。 JavaScript对象特色在实现了对象基本特征的基础上，JavaScript中对象独有的特色是：对象具有高度的动态性，这是因为JavaScript赋予了使用者在运行时为对象添改状态和行为的能力。因此，JavaScript对象的具体设计：具有高度动态性的属性集合。 比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。 下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象o，定义完成之后，再添加它的属性b，这样操作是完全没问题的。 123var o = &#123; a: 1 &#125;;o.b = 2;console.log(o.a, o.b); //1 2 为了提高抽象能力，JavaScript的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。 JavaScript对象的两类属性对JavaScript来说，属性并非只是简单的名称和值，JavaScript用一组特征（attribute）来描述属性（property）。 先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。 value：就是属性的值。 writable：决定属性能否被赋值。 enumerable：决定for in能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 在大多数情况下，我们只关心数据属性的值即可。 第二类属性是访问器（getter/setter）属性，它也有四个特征。 getter：函数或undefined，在取属性值时被调用。 setter：函数或undefined，在设置属性值时被调用。 enumerable：决定for in能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。 访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。 我们通常用于定义属性的代码会产生数据属性，其中的writable、enumerable、configurable都默认为true。我们可以使用内置函数 Object.getOwnPropertyDescripter来查看，如以下代码所示： 12345var o = &#123; a: 1 &#125;;o.b = 2;//a和b皆为数据属性Object.getOwnPropertyDescriptor(o,\"a\") // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(o,\"b\") // &#123;value: 2, writable: true, enumerable: true, configurable: true&#125; 我们在这里使用了两种语法来定义属性，定义完属性后，我们用JavaScript的API来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable都是默认值为true。 如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下： 1234567var o = &#123; a: 1 &#125;;Object.defineProperty(o, \"b\", &#123;value: 2, writable: false, enumerable: false, configurable: true&#125;);//a和b都是数据属性，但特征值变化了Object.getOwnPropertyDescriptor(o,\"a\"); // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(o,\"b\"); // &#123;value: 2, writable: false, enumerable: false, configurable: true&#125;o.b = 3;console.log(o.b); // 2 这里我们使用了Object.defineProperty来定义属性，这样定义属性可以改变属性的writable和enumerable。 我们同样用Object.getOwnPropertyDescriptor来查看，发现确实改变了writable和enumerable特征。因为writable特征为false，所以我们重新对b赋值，b的值不会发生变化。 在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性，代码如下所示： 1234var o = &#123; get a() &#123; return 1 &#125; &#125;;console.log(o.a); // 1//注意，访问访问器属性和访问数据属性一致，不用加（） 访问器属性跟数据属性不同，每次访问属性都会执行getter或者setter函数。这里我们的getter函数返回了1，所以o.a每次都得到1。 这样，我们就理解了，实际上JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者Symbol为key，以数据属性特征值或者访问器属性特征值为value。 对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用key来查找value的字典）。我们以上面的对象o为例，你可以想象一下“a”是key。 {writable:true,value:1,configurable:true,enumerable:true}是value。以前写的JS数据类型已经介绍了Symbol类型，能够以Symbol为属性名，这也是JavaScript对象的一个特色。 总结追本溯源，以面对对象的基本原则和面对对象的基本特征来看，JavaScript只是与主流的Java、C++等面对对象语言采用了不同的设计思路，这样的对象系统设计虽然特别，但是JavaScript提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式，所以它也是正统的面向对象语言。 如果想完全理解JavaScript对象，不能以Java、C#这些“基于类的面向对象”相关的知识，回到人类对对象的朴素认知和面向对象的语言无关基础理论，我们就能够理解JavaScript面向对象设计的思路。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://liruisen.github.io/tags/JS高级/"},{"name":"面对对象","slug":"面对对象","permalink":"https://liruisen.github.io/tags/面对对象/"}]},{"title":"EF使用MySQL","slug":"2018-06-09 EF使用MySQL","date":"2018-06-09T08:58:13.000Z","updated":"2019-06-21T08:29:20.879Z","comments":true,"path":"2018/06/09/2018-06-09 EF使用MySQL/","link":"","permalink":"https://liruisen.github.io/2018/06/09/2018-06-09 EF使用MySQL/","excerpt":"","text":"新项目需要使用MVC+EF+MySQL，以前使用的数据库都是微软的亲儿子SQL Server，所以在使用的时候基本没有遇到过什么问题，但是这次在使用MySQL的时候却一直出现问题，看到的博客很多，千篇一律还没能解决问题，整理此博客，用以记录与分享 EF如何使用SQL Server作为数据源不再多说，不太了解的话查看此博客，下面将讲述EF如何使用MySQL ，本次开发环境为 VS2017，MySQL版本为：MySQL5.5（影响不大） [TOC] 1.配置环境添加实体数据模型在项目 &gt; 添加 &gt; 新建项 &gt; 数据 &gt; ADO.NET实体数据模型 &gt; 添加 &gt; 从数据生成 &gt; 新建连接 选择数据源 在这里可以看到，并没有MySQL的数据源。这是因为没有安装MySQL与VS的集成组件下载地址和MySQL连接组件下载地址，安装完毕后就有了。 在这里插入图片描述 2.使用Nuget 安装 MySQL.Data.Entity 和 MySQL.Data划重点,这里容易出问题常见问题 (1) .闪退在上一步，安装完 mysql-connector-net 组件 和 mysql-for-visualstudio 组件后，虽然在VS上出现了 MySQL Database 选项，但是如果直接点击继续的话，会出现闪退。这是因为没有在Nuget中安装 MySQL.Data.Entity 和 MySQL.Data 这两个包。 如同在使用 SQL Server 作为数据源的时候，需要在 Nuget 中安装 EntityFramwork 包，才能正常创建ADO.NET实体数据模型，这里也是一样，如果不安装 MySQL.Data.Entity 和 MySQL.Data 这两个包，同样无法创建以 MySQL 为数据源的 ADO.NET 实体数据模型。 (2) .您的项目引用了最新实体框架；但是，找不到数据链接所需的与版本兼容的实体框架数据库提供程序……上面在Nuget中，安装过 MySQL.Data.Entity 和 MySQL.Data 这两个包后，应该就可以进入下一步了，但是这里面可能还会遇到另外一个问题 您的项目引用了最新实体框架；但是，找不到数据链接所需的与版本兼容的实体框架数据库提供程序…… 如图所示： 您的项目引用了最新实体框架；但是，找不到数据链接所需的与版本兼容的实体框架数据库提供程序 这个问题困扰了我很久，在网上找到了很多关于这个问题的博客，虽然博主都给了解决方案，但是我使用那些解决方案并没有能很好的解决问题，最后找到了其他的、更简单的解决方案解决了问题。 大家还记得前面安装的 mysql-connector-net 组件 吗， MySQL官网上这个组件的版本最新的是 8.0.12，但是 VS2017 的 Nuget 包管理器中 MySQL.Data.Entity 稳定版最新版本为6.10.8 MySQL.Data稳定版最新版本为 8.0.12 ，出现上面的报错，就是因为这三者版本不一致,三者版本必须一致 ，否则就会报这个错误！ 三者版本 可以先添加指定版本的 MySQL.Data.Entity 这样会自动添加上对应版本的 MySQL.Data 这样就可以顺利创建 ADO.NET实体数据模型了 在这里插入图片描述 (3) .上述三者版本一致，但是仍然不能正常创建检查项目的 .netframwork 版本，不同的 MySQL.Data.Entity 版本有不同的 .netframwork 最低版本支持，在 packages 文件夹或 Nuget 中查看所需支持的最低 .netframwork 版本，检测所建项目的 .netframwork 版本是否符合要求。 (4) 给定关键字不在字典中 这个问题开始并没有碰到，一切正常，不过后来在别人电脑上操作，上午创建一切正常，但是下午就出现了这个问题，然后就一直无法创建，在CSDN上发现了一篇博客，解决了问题，后面为参考博客原文： ——————————————————————参考博客——————————————————————— 导致这个问题的原因有很多，比如数据库编码不一致、mysql connector的版本不一致等等 解决办法： 1.确报VS中使用的MySQL版本（NuGet获取相应即可）与当前电脑安装的Mysql Connector版本一致； 2.关闭VS ，在系统盘中找到文件 DefaultView.SEView 并删除。 通常路径为：用户\\AppData\\Microsoft\\VisualStudio\\xx\\ServerExplorer 参考原文链接：https://blog.csdn.net/iceagezh/article/details/78924154 ——————————————————————参考博客End————————————————————— 我使用的是第二种方案解决的问题，因为前面三者的版本都一致，不过 DefaultView.SEView 这个文件并不是很好找，根据博主给的地址没有找到，我使用的是 Everything 软件找到的这个文件，并删除，找到了2个这个文件，都删除了，通过删除后的VS的状态，怀疑这个文件是用来保存每次连接数据库的信息文件，因为删除过这个文件后曾经在VS中使用EF连接数据库的账号密码都清空了，不过已经能正常创建 ADO.NET 实体数据模型了。 总结这次遇到了不少的问题，但是本质上来说也算不上是特别严重的问题，VS2017是真的好用，微软对亲儿子和其他人家的儿子态度真是不同！下面是问题解决总结： 安装 mysql-connector-net 组件 和 mysql-for-visualstudio 组件，mysql-for-visualstudio 组件无版本要求，但是 mysql-connector-net 组件需要与后面在 Nuget 中引用的 MySQL.Data.Entity 和 MySQL.Data 版本一致。如果不安装这两个组件，在选择数据源的时候不会出现MySQL Database选项 “引用了最新的实体框架，但是找不到数据链接所需的与版本兼容的实体框架数据库提供程序…”，检查 mysql-connector-net 组件、 MySQL.Data.Entity 包、MySQL.Data 包，三者的版本是否一致 不能引用 MySQL.Data.Entity 包、MySQL.Data 包，检查项目的 .netframework 版本是否满足这两个包的最低版本需求。 “给定关键字不在字典中”，关闭VS，找到并删除 DefaultView.SEView 文件。","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://liruisen.github.io/categories/ASP-NET/"},{"name":"MVC","slug":"ASP-NET/MVC","permalink":"https://liruisen.github.io/categories/ASP-NET/MVC/"}],"tags":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://liruisen.github.io/tags/ASP-NET-MVC/"},{"name":"EF","slug":"EF","permalink":"https://liruisen.github.io/tags/EF/"},{"name":"MySQL","slug":"MySQL","permalink":"https://liruisen.github.io/tags/MySQL/"}]},{"title":"JS的数据类型转换","slug":"前端6. 2018-5-12 JS：数据类型转换","date":"2018-05-12T03:20:04.000Z","updated":"2019-07-26T02:31:20.916Z","comments":true,"path":"2018/05/12/前端6. 2018-5-12 JS：数据类型转换/","link":"","permalink":"https://liruisen.github.io/2018/05/12/前端6. 2018-5-12 JS：数据类型转换/","excerpt":"","text":"JS类型转换前面讲了基本类型，这篇来总结下类型转换。 因为JS是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。 其中最为臭名昭著的是JS中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。这里也不打算讲解==的规则，它属于设计失误，并非语言中有价值的部分，很多实践中推荐禁止使用“ ==”，而要求程序员进行显式地类型转换后，用 === 比较。 其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示： 在这个里面，较为复杂的部分是Number和String之间的转换，以及对象跟基本类型之间的转换。 StringToNumber字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如： 30； 0b111； 0o13； 0xFF。 此外，JavaScript支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的e来表示： 1e3； -1e-2。 需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。在不传入第二个参数的情况下，parseInt只支持16进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。 在一些古老的浏览器环境中，parseInt还支持0开头的数字作为8进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入parseInt的第二个参数，而parseFloat则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。 来看2个例题： 12345var arr = [\"\", '1', '2', '3'];var r = arr.map(parseInt);var arr2=['1','4','9','16']; var r2=arr2.map(parseInt) 这两个例题的类型是一致的，只是数组不同。去试试输出结果是什么？ 跟你想象的是否一致？因为传给map的参数有三个：当前的值、当前值的索引、以及当前数组 123456789101112131415161718当前的值(currentValuve)//依次是&apos;1&apos;,&apos;4&apos;,&apos;9&apos;,&apos;16&apos;当前值的索引(currentIndex)//依次是0,1,2,3以及当前数组(currentArray)//[&apos;1&apos;,&apos;4&apos;,&apos;9&apos;,&apos;16&apos;],每次都是这个而每次使用parseInt()函数的时候，却只传入了两个值(currentValue,currentIndex)所以结果就是:parseInt(&apos;1&apos;,0)//1 (第二个参数假如经过 Number 函数转换后为 0 或 NaN，则将会忽略——Mozilla官方文档)parseInt(&apos;4&apos;,1)//非法，NaNparseInt(&apos;9&apos;,2)//非法，NaNparseInt(&apos;16&apos;,3)//这里值得注意,在解析字符串&apos;16&apos;的时候，发现6大于或等于3，所以其后的数字都被忽略，只剩下一个1返回了(如果 parseInt 遇到了不属于radix参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。——Mozilla官方文档)最后，关于 [&quot;&quot;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;] 输出为 NaN,NaN,NaNNaN 是因为第一个为空，转换为NaN，后面的为parseInt(1,1),parseInt(2,2),parseInt(3,3)为NaN则是因为数值不能大于进制基数，例如2进制的最大值为1,10进制的最大值为9 多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。 如果不使用 Number、parseInt、parseFloat怎么把字符串转换为number呢？ 这就是js中把字符类型转成数字类型第三种方法：利用js变量弱类型转换。 1234var num = +\"1000\"\"1000\"&gt;&gt;&gt;0~~\"1000\"\"1000\"*1 详细步骤可看：这里 第4种方法则是利用数学函数 123Math.floor(\"1000\")Math.round(\"1000\")Math.ceil(\"1000\") NumberToString在较小的范围内，数字到字符串的转换是完全符合我们直觉的十进制表示。当Number绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，其实就是保证了产生的字符串不会过长。具体的算法，可以去参考JavaScript的语言标准。因为在日常开发中很少用到，所以这里就不去详细地讲解了。 装箱每一种基本类型Number、String、Boolean、Symbol在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。 前面说过，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的call方法来强迫产生装箱。我们定义一个函数，函数里面只有return this，然后我们调用函数的call方法到一个Symbol类型的值上，这样就会产生一个symbolObject。我们可以用console.log看一下这个东西的type of，它的值是object，我们使用symbolObject instanceof 可以看到，它是Symbol这个类的实例，我们找它的constructor也是等于Symbol的，所以我们无论从哪个角度看，它都是Symbol装箱过的对象： 12345var symbolObject = (function()&#123; return this; &#125;).call(Symbol(\"a\"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true 装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。使用内置的 Object 函数，我们可以在JavaScript代码中显式调用装箱能力。 12345var symbolObject = Object(Symbol(\"a\"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true 每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取： 123var symbolObject = Object(Symbol(\"a\"));console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol] 在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。 但需要注意的是，call本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。 拆箱在JavaScript标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。 对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。 拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。 12345678var o = &#123; valueOf : () =&gt; &#123;console.log(\"valueOf\"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log(\"toString\"); return &#123;&#125;&#125;&#125;o * 2// valueOf// toString// TypeError 我们定义了一个对象o，o有valueOf和toString两个方法，这两个方法都返回一个对象，然后我们进行o*2这个运算的时候，你会看见先执行了valueOf，接下来是toString，最后抛出了一个TypeError，这就说明了这个拆箱转换失败了。 到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从o*2换成 String(o)，那么你会看到调用顺序就变了。 123456789 var o = &#123; valueOf : () =&gt; &#123;console.log(\"valueOf\"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log(\"toString\"); return &#123;&#125;&#125; &#125;String(o) // toString // valueOf // TypeError 不过如果把 String(0)转为o+&quot;2&quot;则执行顺序将会变为 123456789var o = &#123; valueOf : () =&gt; &#123;console.log(\"valueOf\"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log(\"toString\"); return &#123;&#125;&#125; &#125; o+\"2\" // valueOf // toString // TypeError 在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。 1234567891011var o = &#123; valueOf : () =&gt; &#123;console.log(\"valueOf\"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log(\"toString\"); return &#123;&#125;&#125;&#125;o[Symbol.toPrimitive] = () =&gt; &#123;console.log(\"toPrimitive\"); return \"hello\"&#125;console.log(o + \"\")// toPrimitive// hello 总结有一个说法是：程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以要对它格外重视。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://liruisen.github.io/tags/JS高级/"}]},{"title":"JS的数据类型","slug":"前端5. 2018-5-10 JS：JS的数据类型","date":"2018-05-10T03:20:04.000Z","updated":"2019-07-26T02:31:14.229Z","comments":true,"path":"2018/05/10/前端5. 2018-5-10 JS：JS的数据类型/","link":"","permalink":"https://liruisen.github.io/2018/05/10/前端5. 2018-5-10 JS：JS的数据类型/","excerpt":"","text":"上篇 JS 的博客写了我看大牛划分的 JS 顶层体系分类，还记得吗？是 语义、文法、运行时，这篇文章就从运行时的角度去看 JavaScript 的类型系统。 运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于7个类型之一。从变量、参数、返回值到表达式中间结果，任何JavaScript代码运行过程中产生的数据，都具有运行时类型。 在正式开始之前，我先留下几个问题，如果能全部理解这些问题，那就很容易就能理解后面的内容，不过有疑惑，那就带着问题去下面的内容中找答案吧，请听题： 为什么有的编程规范要求用void 0代替undefined？ 字符串有最大长度吗？ 0.1 + 0.2不是等于0.3么？为什么JavaScript里不是这样的？ ES6新加入的Symbol是个什么东西？ 为什么给对象添加的方法能用在基本类型上？ 类型avaScript语言的每一个值都属于某一种数据类型。JavaScript语言规定了7种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这7种语言类型是： Undefined； Null； Boolean； String； Number； Symbol； Object。 除了ES6中新加入的Symbol类型，剩下6种类型都是常见的数据类型了，但是，要想回答文章一开始的问题，就要重新复习下这些数据类型了。 Undefined、Null第一个问题是，为什么有的编程规范要求用void 0代替undefined？现在我们就分别来看一下。 Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量undefined（就是名为undefined的这个变量）来表达这个值，或者 void 运算来把任一一个表达式变成 undefined 值。 但是JavaScript的代码undefined是一个变量，而并非是一个关键字，因此为了避免undefined在局部环境中无意中被篡改，因此使用 void 0 来获取undefined值。在全局环境中 undefined是无法被篡改的。 Undefined跟 null 有一定的表意差别，null表示的是：“定义了但是为空”。所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。 Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，都可以放心用 null 关键字来获取 null 值。 BooleanBoolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。这个类型很简单，就不做过多介绍了。 StringString 用于表示文本数据。String 有最大长度是 2^53 - 1，不过因为String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。 JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征 NumberNumber类型表示我们通常意义上的“数字”。 JavaScript中的Number类型有 18437736874454810627(即2^64-2^53+3) 个值。但是JavaScript为了表达几个额外的语言场景（比如不让除以0出错，而引入了无穷大的概念），规定了几个例外情况： NaN，占用了 9007199254740990，这原本是符合IEEE规则的数字，在JS表示为：不是数字； Infinity，无穷大； -Infinity，负无穷大。 另外，值得注意的是，JavaScript中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以-0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。 根据双精度浮点数的定义，Number类型中有效的整数范围是-0x1fffffffffffff至0x1fffffffffffff，所以Number无法精确表示此范围外的整数。同样根据浮点数的定义，非整数的Number类型无法用 ==（===也不行） 来比较，一段著名的代码，这也正是第三题的问题，为什么在JavaScript中，0.1+0.2不能=0.3： 1console.log( 0.1 + 0.2 == 0.3); 这里输出的结果是false，说明两边不相等的，这是浮点运算的特点，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用JavaScript提供的最小精度值： 1console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON); 检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。 SymbolSymbol 是 ES6 中引入的新类型，它是一切非字符串的对象key的集合，在ES6规范中，整个对象系统被用Symbol 重塑。 Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol也不相等。创建 Symbol 的方式是使用全局的 Symbol 函数。例如： 1var mySymbol = Symbol(\"my symbol\"); 一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为： 12345678910111213var o = new Object o[Symbol.iterator] = function() &#123; var v = 0 return &#123; next: function() &#123; return &#123; value: v++, done: v &gt; 10 &#125; &#125; &#125; &#125;; for(var v of o) console.log(v); // 0 1 2 3 ... 9 代码中定义了iterator之后，用for(var v of o)就可以调用这个函数，然后我们可以根据函数的行为，产生一个for…of的行为。 这里给对象o添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个0到10的迭代器，之后我们就可以在for of中愉快地使用这个o对象啦。 这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。 Symbol内容很多，这里只是最基本的内容，以后再详细写写。 ObjectObject 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object表示对象的意思，它是一切有形和无形物体的总称。 最后我们来看一看，为什么给对象添加的方法能用在基本类型上？ 在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是key-value结构，key可以是字符串或者 Symbol类型。 JS中的对象和C#中的对象区别： 提到对象，必须要提到一个概念：类。在C#和Java中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把JavaScript的“类”与类型混淆。事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而JavaScript中是无法自定义类型的。 JavaScript中的几个基本类型，都在对象类型中有一个“亲戚”。它们是： Number； String； Boolean； Symbol。 因此，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。 Number、String和Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。 JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如： 1console.log(&quot;abc&quot;.charAt(0)); //a 甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了hello方法，在任何 Symbol 类型变量都可以调用。 12345Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;); var a = Symbol(&quot;a&quot;); console.log(typeof a); //symbol，a并非对象 a.hello(); //hello，有效 所以最后的一道问题，答案就是. 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。 总结事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JS语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。 在表格中，多数项是对应的，但是请注意object——Null和function——Object是特例，我们理解类型的时候需要特别注意这个区别。 从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但JS之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://liruisen.github.io/tags/JS高级/"}]},{"title":"JS学习体系","slug":"前端4. 2018-4-18 JS：基本架构和目录","date":"2018-04-18T03:20:04.000Z","updated":"2019-07-26T02:31:07.041Z","comments":true,"path":"2018/04/18/前端4. 2018-4-18 JS：基本架构和目录/","link":"","permalink":"https://liruisen.github.io/2018/04/18/前端4. 2018-4-18 JS：基本架构和目录/","excerpt":"","text":"大二的时候就学习了JS，但是那个时候主要还是在学习JS的DOM操作和事件，关于W3CSchool中JS的其他部分，东哥并没有深入的去讲解，但是我的性子耐不住啊，在学过DOM操作和事件以后，就去查了 W3CSchool、CSDN、敲了Demo、问了东哥，得出这个系列的博客。 构建JS的知识框架关于JS在深入学习以后，发现东西真是多，类型转换、this指针、闭包、变量提升、作用域链、原型链……这里每个知识点都能单独拿出来说，不过这些知识点之间，没有任何逻辑关系。它们既不是并列关系，又不是递进关系，合在一起，也就没有任何意义，这样不符合我整理知识体系的习惯。我在看过一篇博客时，有位博主的观点我觉得很厉害，他把JS的体系设定为：文法、语义、运行时。 这样，JavaScript的任何知识都不会出现在这个范围之外，这是知识架构的完备性。再往下细分一个层级，就变成了这个样子： 文法 词法 语法 语义 运行时 类型 执行过程 其中，文法可以分成词法和语法，这来自编译原理的划分，同样是完备的。语义则跟语法具有一一对应关系，这里暂时不区分。 对于运行时部分，这个划分保持了完备性，我们都知道：程序 = 算法 + 数据结构，那么，对运行时来说，类型就是数据结构，执行过程就是算法。 再往下细分的时候，就会看到熟悉的概念了，词法中有各种直接量、关键字、运算符，语法和语义则是表达式、语句、函数、对象、模块，类型则包含了对象、数字、字符串等…… 总结学习的过程就是知识架构不断进化的过程，通过知识架构的自然延伸，我们就能更轻松的记忆一些原本难以记住的点，还可以发现被忽视的知识盲点。同时，在学习时有着一个良好的知识体系架构，在学习的时候就能把相应的知识分配到相应的知识体系划分之中，没有人能够记住所有的知识，在面试时，当不可避免地谈到一个记不住的知识，如果你能快速定位到它在知识架构中的位置，把一些相关的点讲出来，想必这也能捞回不少分。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://liruisen.github.io/tags/JS高级/"}]},{"title":"怎么使用HTML语义化？","slug":"前端2. 2018-3-18 HTML语义化2：为什么使用","date":"2018-03-18T03:20:04.000Z","updated":"2019-07-26T01:10:34.468Z","comments":true,"path":"2018/03/18/前端2. 2018-3-18 HTML语义化2：为什么使用/","link":"","permalink":"https://liruisen.github.io/2018/03/18/前端2. 2018-3-18 HTML语义化2：为什么使用/","excerpt":"","text":"上篇文章总结了下关于HTML的语义化，以及我在学习语义化标签后，对语义化标签使用的看法。这篇主要写我觉的比较重要的语义标签使用场景以及使用。 与C#这样严格的编程语言相比，HTML中语义标签的使用更接近我们平常说话用的自然语言。我们平时说话并没有唯一的标准措辞，语义标签的使用也是一样。下面写几个我觉得比较重要的语义标签使用场景。 作为自然语言延伸的语义类标签语义这个词从定义上就是文科的，因此语义问题是个文科问题，所以我们这里讲语义标签的使用的第一个场景，也是最自然的使用场景，就是：作为自然语言和纯文本的补充，用来表达一定的结构或者消除歧义。 先举个例子： 如图，在【犀利】的上方可以加上标注，但是这种操作如果使用H5以前的内容来做的话，花费精力还是能够实现的。但是在HTML5中，就引入了这个表示ruby的标签，它由ruby、rt、rp三个标签来实现。 所以说，这些情况里存在的语义，其实原本就存在了，只是我们用纯文字是没法表达的，HTML作为一种“超文本”语言，支持这些文字表达就是必要的了。 避免歧义除了上述所说的作为自然语言延伸到语义类标签出现以外，还有一种情况是，HTML的有些标签实际上就是必要的，甚至必要的程度可以达到：如果没有这个标签，文字会产生歧义的程度。 这里介绍 em 标签 例如下面这句话： 1今天我吃了一个苹果 看上去它很清楚，但是实际上，这句话放到不同上下文中，可能表达完全不同的意思。 12昨天我吃了一个香蕉。今天我吃了一个苹果。 再比如： 12昨天我吃了两个苹果。今天我吃了一个苹果。 试着读一读，这两段里面的“今天我吃了一个苹果”，你是不是发现读音不自觉地发生了变化？ 实际上，不仅仅是读音，这里的意思也发生了变化。前一段中，表示我今天吃的是苹果，而不是别的什么东西，后一段中，则表示我今天只吃了一个苹果，没有多吃。 当没有上下文时，如何消除歧义呢？这就要用到em标签了。em表示重音： 12今天我吃了一个&lt;em&gt;苹果&lt;/em&gt;。今天我吃了&lt;em&gt;一个&lt;/em&gt;苹果。 通过em标签，我们可以消除这样的歧义。 一些文章常常会拿em和strong做对比，实际上，只要理解了em的真正意思，它和strong可谓天差地别，并没有任何混淆的可能。 作为标题摘要的语义类标签介绍完自然语言的语义场景后，另一个语义重要使用场景，就是文章的结构。中国古代小说就形成了“章-回”的概念，西方的戏剧也有幕的区分，所以人类的自然语言作品也是如出一辙。 HTML也应该支持这样的需求。HTML语义标签中，有不少是用于支持这样的结构的标签。 语义化的HTML能够支持自动生成目录结构，HTML标准中还专门规定了生成目录结构的算法，即使我们并不打算深入实践语义，也应该尽量在大的层面上保证这些元素的语义化使用。 从HTML 5开始，就有了section标签，这个标签可不仅仅是一个“有语义的div”，它会改变h1-h6的语义。section的嵌套会使得其中的h1-h6下降一级，因此，在HTML5以后，只需要section和h1就足以形成文档的树形结构： 12345678910111213&lt;section&gt; &lt;h1&gt;HTML语义&lt;/h1&gt; &lt;p&gt;balah balah balah balah&lt;/p&gt; &lt;section&gt; &lt;h1&gt;弱语义&lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt;结构性元素&lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt;......&lt;/section&gt; 这段代码同样会形成前面例子的标题结构： HTML语义 弱语义 结构性元素 …… 作为整体结构的语义类标签最后一个场景，随着越来越多的浏览器推出“阅读模式”，以及各种非浏览器终端的出现，语义化的HTML适合机器阅读的特性变得越来越重要。 应用了语义化结构的页面，可以明确地提示出页面信息的主次关系，它能让浏览器很好地支持“阅读视图功能”，还可以让搜索引擎的命中率提升，同时，它也对视障用户的读屏软件更友好。（如果一个页面只有 span 和 div，视障软件如果把这个网页读给用户？ 读 “ div 开始 class=”tile” 今天天气很好 div 结束” 还是读 “标题：今天天气很好” 那个方式更好呢？） 正确使用整体结构类的语义标签，可以让页面对机器更友好。比如，这里一个典型的body类似这样： 123456789101112131415161718&lt;body&gt; &lt;header&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/header&gt; &lt;aside&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/aside&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;footer&gt; &lt;address&gt;……&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; 在body下面，有一个header，header里面是一个nav，跟header同级的有一个aside，aside里面也有一个nav。接下来是文章的整体，也就是一个一个的section。section里面可能还有嵌套，但是我们就不管了，最后是一个footer，这个footer里面可能有address这样的内容。 除此之外，还有article，article是一种特别的结构，它表示具有一定独立性质的文章。所以，article和body具有相似的结构，同时，一个HTML页面中，可能有多个article存在。 一个典型的场景是多篇新闻展示在同一个新闻专题页面中，这种类似报纸的多文章结构适合用article来组织。 12345678910111213141516171819&lt;body&gt; &lt;header&gt;……&lt;/header&gt; &lt;article&gt; &lt;header&gt;……&lt;/header&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;footer&gt;……&lt;/footer&gt; &lt;/article&gt; &lt;article&gt; …… &lt;/article&gt; &lt;article&gt; …… &lt;/article&gt; &lt;footer&gt; &lt;address&gt;&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; body里面有自己的header和footer，然后里面是竖篇的article，每一个article里面都有自己的header、section、footer。这是一个典型的多文章结构。 在这个结构里，我们看到了一些新标签，逐个介绍一下。 header，如其名，通常出现在前部，表示导航或者介绍性的内容。 footer，通常出现在尾部，包含一些作者信息、相关链接、版权信息等。 header和footer一般都是放在article或者body的直接子元素，但是标准中并没有明确规定，footer也可以和aside，nav，section相关联（header不存在关联问题）。 aside，表示跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容。 aside很容易被理解为侧边栏，实际上二者是包含关系，侧边栏是aside，aside不一定是侧边栏。 aside和header中都可能出现导航（nav标签），二者的区别是，header中的导航多数是到文章自己的目录，而aside中的导航多数是到关联页面或者是整站地图。 最后footer中包含address，这是个非常容易被误用的标签。address并非像date一样，表示一个给机器阅读的地址，而是表示“文章（作者）的联系方式”，address明确地只关联到article和body。 总结根据本篇和上篇文章，介绍了一些基本原则和HTML文档的整体结构，从整体上了解了HTML语义。因此在回答是否要语义化的问题时：我们应该分开一些场景来看语义，把它用在合适的场景下，可以获得额外的效果。 回顾一下本篇的三个明确的场景： 自然语言表达能力的补充； 文章标题摘要； 适合机器阅读的整体结构。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://liruisen.github.io/tags/JS高级/"},{"name":"HTML语义化","slug":"HTML语义化","permalink":"https://liruisen.github.io/tags/HTML语义化/"}]},{"title":"什么是HTML语义化？","slug":"前端1. 2018-3-16 HTML语义化1：是什么","date":"2018-03-16T02:43:04.000Z","updated":"2019-07-26T01:09:36.075Z","comments":true,"path":"2018/03/16/前端1. 2018-3-16 HTML语义化1：是什么/","link":"","permalink":"https://liruisen.github.io/2018/03/16/前端1. 2018-3-16 HTML语义化1：是什么/","excerpt":"","text":"HTML的标签可以分为很多种，比如head里面的元信息类标签，又比如img、video、audio之类的替换型媒体标签，又或者如div、span等布局标签。在HTML5以前以及现在，布局大多使用Div进行布局，但是 H5 标准中一个特点就是标签的语义化。关于什么是语义化的标签、使用他有什么好处，在接触之前我也是不了解的，为了快速开发大多使用 div 进行布局，然后通过有业务含义的class来定义样式，不过最近看到了一些文章讲述语义化标签，也做过一些demo进行测试，那就来记录下最近关于标签语义化的成果。 语义类标签是什么，使用它有什么好处？语义类标签语义类标签也是写代码中经常会用到的一类标签，它们的特点是视觉表现上互相都差不多，主要的区别在于它们表示了不同的语义，比如会经常见到的section、nav、p，这些都是语义类的标签。语义呢，则是我们说话表达的意思，多数的语义实际上都是由文字来承载的。语义类标签则是纯文字的补充，比如标题、自然段、章节、列表，这些内容都是纯文字无法表达的，因此需要依靠语义标签代为表达。 那为什么要用语义呢？在写代码的时候，多数都不用复杂的语义标签， 只靠div 和 span 就能满足开发的需求了，这样做既能不必纠结与使用的语义化标签是否正确，又能快速开发便于后期维护。 HTML原称是超文本标记语言，但是在现在的开发过程中HTML用于描述软件的界面多过于富文本，而软件里面的东西，具体要根据业务划分，实际上几乎是没有语义的。毕竟HTML发明之初也不是用作今天我们所能看到的五彩缤纷的网站门户，举例说，做了一个购物车功能，一定要给每个购物车里的商品套上ul吗？又或者说，加入购物车这个按钮，一定要用Button吗？我觉得没必要，因为这个场景里面，跟文本中的列表，以及表单中的Button，其实已经相差很远了，所以，我觉得在任何软件界面的场景中，直接使用div和span也是可以的。 不过，在很多场景里，语义类标签也有它们自己无可替代的优点。正确地使用语义标签可以带来很多好处 语义类标签对开发者更为友好，使用语义类标签增强了可读性。即便是在没有CSS的时候，开发者也能够清晰地看出网页的结构，也更为便于团队的开发和维护（前提是团队全部使用语义化标签，不然只会一团糟） 十分适宜机器阅读。它的文字表现力丰富，更适合检索（SEO），也可以让搜索引擎爬虫更好地获取到更多有效信息，有效提升网页的搜索量，并且语义类还可以支持读屏软件，根据文章可以自动生成目录等等。 不过，不恰当地使用语义标签，反而会造成负面作用。这里举一个常见的误区作为例子。我们都知道ul是无序列表，ol是有序列表，所以不应该给所有并列关系的元素都套上ul。 实际上， ul 是长成下面的这种样子的(以下来自HTML标准)。 I have lived in the following countries: Switzerland Norway United Kingdom United States ul多数出现正在行文中间，它的上文多数在提示：要列举某些项。但是，如果所有并列关系都用ul，会造成大量冗余标签。 错误地使用语义标签，会给机器阅读造成混淆、增加嵌套，给CSS编写加重负担。错误地使用语义标签，会给机器阅读造成混淆、增加嵌套，给CSS编写加重负担。 因此，对于语义标签，在看过多位大牛的分析文章后，我觉得：“用对”比“不用”好，“不用”比“用错”好。但是，我觉得有理想的前端工程师还是应该去追求“用对”它们。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"JS高级","slug":"JS高级","permalink":"https://liruisen.github.io/tags/JS高级/"},{"name":"HTML语义化","slug":"HTML语义化","permalink":"https://liruisen.github.io/tags/HTML语义化/"}]},{"title":"EF框架使用","slug":"2017-08-11 EF框架","date":"2018-03-11T08:58:13.000Z","updated":"2019-06-21T08:32:46.036Z","comments":true,"path":"2018/03/11/2017-08-11 EF框架/","link":"","permalink":"https://liruisen.github.io/2018/03/11/2017-08-11 EF框架/","excerpt":"","text":"本博客所有案例的开发环境为 VS2013 + SQL Server 2012 Entity Framework实体框架简介Entity Framework 实体框架（EF）是ADO.NET的开源对象关系映射（ORM）框架，它是 .NET Framework 的一部分，是一组支持开发面向数据的软件应用程序的技术。微软为实现 .NET 跨平台，将 EF 从 .NET 分离，使EF更加组件化。2016年6月27日，Entity Framework 7作为实体框架核心 1.0 发布，与 ASP.Net Core 1.0 和 .Net Core 1.0 一起发布，重命名为凸显出它是完全重新而不是增量升级，同时，EF7并不会取代EF6。 在EF中的实体数据模型（EDM）由以下三种模型和具有相应文件扩展名的映射文件进行定义。概念架构定义语言文件（.csdl）——定义概念模型存储架构定义语言文件（.ssdl）——定义存储模型映射规范语言文件（.msl）——定义存储模型与概念模型之间的映射M。 实体框架 使用这些基于XML的模型和映射文件将对概念模型中的实体和关系的创建、读取、更新、和删除操作转换为数据源中的等效操作。EDM 甚至支持将概念模型中的实体映射到数据源中的存储过程。 ORM（Object Relational Mapping）框架采用元数据来描述对象一关系映射细节，元数据一般采用XML格式，并且存放在专门的对象一映射文件中。 广义上来说，ORM 可以被认为是 面向对象模型和关系型数据库的数据结构之间的相互转换。 狭义上来说，ORM 可以被认为是，基于关系型数据库的数据存储，实现了一个虚拟的面向对象的数据访问接口。理想情况下，基于这样一个面对对象的接口，持续化一个OO对象应该不需要了解任何关系型数据库存储数据的实现细节。 其他.NET ORM框架: PetaPoco : 与完备的 ORM 框架不同，PetaPoco 更加注重易用性和性能。使用 PataPoco 只需要引入一个C#文件，可以使用强类型的 POCO（Plain Old CLR Object）,并支持 T4 模板生成的类等。此外，由于 PetaPoco 是开源项目，因此添加条件来处理如空间数据等特定情况会很容易。 Dapper :性能方面高于 PetaPoco，速度只稍逊于手工编码的数据访问层（DAL、Data AccessLayer），还有一些对初学者会有帮助的、位于官网上的系列博文和一些独立博文教程。 一、DataFirst使用EF，创建Model （DataFirst） 在解决方案中，创建所使用的项目。例如：ASP网站项目、WinForm窗体项目…… 在新建的项目中，添加 &gt; 新建项 &gt; 数据 &gt; ADO.NET实体数据模型（.edmx） 在新建的.edmx中选择：从数据库生成（DatabaseFirst） 选择新建连接，填写连接数据库 &gt; 填写登录数据库信息 &gt; 选择或输入需要生成模型的数据库名称. 选择需要创建模型的表、视图、存储过程 点击下一步，直接生成（有些电脑可能会出现警告信息，忽视即可）。 ​ （图片不清晰的话请在：浏览器上，鼠标右键，在新标签页中打开图片。即可看到清晰图片） 使用EF创建的内容创建完成后，项目会默认引入两个命名空间：EntityFramework、System.Data.Entity 最外层为.edmx文件，EF模型设计器，展示从数据库创建的模型，包括：表名、属性（表字段）、导航属性（外键、表与表之间的对应关系）、表与表之间1对1、1对多的关系。 Model1.Context.tt、Model.Designer.cs、Model.edmx.diagram、Model1.tt Model1.Context.tt：包含Model1.Context.cs。Model1.Context.tt由T4模板生成，不可更改，Model1.Context.cs继承自DbContext，包括构造方法（继承自父类的构造方法，并在此传递配置文件的数据库连接字符串）、各个表所对应的Dbset&lt;T&gt;类型的自动属性。 Model.Designer.cs：自动生成，无需更改 Model.edmx.diagram：描述edmx文件的元素信息（名称、位置……） Model1.tt：包含生成的Model.cs，自身由T4模板生成，无需修改 使用EF进行增删改查查询123456789StudentMISEntities stu = new StudentMISEntities();//IQueryable&lt;Users&gt; userInfoList=from u in stu.Usersvar userInfoList = from u in stu.Users where u.id == 10 select u;foreach (var item in userInfoList)//EF延迟加载机制，数据用到的时候才去数据库中查询，不用的时候不去查询，提高程序性能&#123; Response.Write(item.uName);&#125; 增加1234567Users userInfo = new Users();userInfo.uName = \"2333\";userInfo.uPassword = \"123\";userInfo.uRole = \"学生\";StudentMISEntities stu = new StudentMISEntities();//创建EF数据操作类实例stu.Users.Add(userInfo);//把数据添加到EF，并添加标记stu.SaveChanges();//把数据保存到数据库 修改12345678910111213141516StudentMISEntities stu = new StudentMISEntities();var userInfoList = from u in stu.Users where u.id == 16 select u;Users userInfo = userInfoList.FirstOrDefault();//返回第一个元素，如果没有的话，返回nullif (userInfo!=null)&#123; userInfo.uPassword = \"12345678\"; stu.Entry&lt;Users&gt;(userInfo).State = System.Data.Entity.EntityState.Modified;//添加修改标记 stu.SaveChanges(); Response.Write(userInfo.uPassword);&#125;else&#123; Response.Write(\"要修改的数据不存在\");&#125; 删除12345678910111213141516 StudentMISEntities stu = new StudentMISEntities(); var userInfoList = from u in stu.Users where u.id == 17 select u;Users userInfo = userInfoList.FirstOrDefault();//返回第一个元素，如果没有的话，返回nullif (userInfo!=null)&#123; //stu.Users.Remove(userInfo); stu.Entry&lt;Users&gt;(userInfo).State = System.Data.Entity.EntityState.Deleted;//添加删除标记 stu.SaveChanges(); Response.Write(\"已删除\");&#125;else&#123; Response.Write(\"要删除的数据不存在\");&#125; 二、ModelFirst 除了支持 DatabaseFirst 外，EF 还支持 ModelFirst 、 CodeFirst，这两种类型不同于DatabaseFirst 先建立好数据库而后映射 Model ， ModelFirst 是通过 Model 映射创建数据库，而 CodeFirst 类似于 ModelFirst， 通过代码逻辑自行创建 Model 并映射数据库，但是不同于 ModelFirst 由 VS 自动创建。 Model先行，通过Model创建数据库 步骤： 在新建的项目中，添加 &gt; 新建项 &gt; 数据 &gt; ADO.NET实体数据模型（.edmx） 在新建的.edmx中选择：空模型（ModelFirst） 在.edmx图形化窗口中，右键 &gt; 新增 &gt; 实体 在新增实体页面 填写: 实体名（表名）、是否创建键属性（是否创建主键）、属性名称、属性类型 &gt; 确定 在.edmx图形化窗口中，在 实体 上右键 &gt; 新增 &gt; 标量属性（表字段） 选中标量属性，按快捷键 F4 或调出属性面板，可以更改标量属性的：类型、名称、长度（必改） 在多个实体，且实体之间有关联的时候，在.edmx图形化设计页面中，右键 &gt; 新建 &gt; 关联 在添加关联页面设置内容（默认即可） 在所有模型创建完毕，在.edmx页面 右键 &gt; 根据模型生成数据库 在 “生成数据库 向导” 页面，新建数据库连接 &gt; 设置连接字符串 &gt; 选择需要创建表的数据库 &gt; 点击下一步 生成数据库向导中，会生成 DDL（数据库设计语言），并另存为 .sql 文件 生成 .sql 文件后，建立的Model并没有映射到数据库引擎中，需要在 .sql 文件中，右键 &gt; 执行，即可。 ​ （图片不清晰的话请在：浏览器上，鼠标右键，在新标签页中打开图片。即可看到清晰图片） 注意事项： 新建 标量属性 后，需要在属性面板对 标量属性的 长度 和 数据类型 进行限制，string 长度即为数据库内字段的 NVarChar 的长度 。 在 .edmx 图形化页面 新建完实体 后，解决方案里面可能没有生成 Model.tt 文件（包含 Model 模型.cs），这时候在 .edmx 图形化页面: 右键 &gt; 添加代码生成项 &gt; 数据 &gt;EF 版本.x DbContext 生成器 &gt; 确定 关于实体更新 需映射数据库更新 更新实体后，VS 在生成的DDL数据库脚本中，是把原先创建好的表全部删除，再重新创建更新后的实体所对应的表，如果原数据表中存在数据，数据也会一并删除。（2）. 在更新数据库时一定要谨慎，做好数据库备份，同时如果只是小的改动（扩大字符长度），手动在数据库里 修改即可，或者仅把更新的sql脚本部分拷贝出来，复制到SQL Server执行 三、CodeFirst先写代码，通过代码创建实体，映射数据库 步骤： 新建项目，在项目里面通过 NuGet程序包 安装EntityFramework（该操作会自动引入EntityFramework以及相对应的命名空间） 在配置文件里面添加连接字符串 123&lt;connectionStrings&gt; &lt;add name=\"CodeFirstDemo\" connectionString=\"server=.;uid=用户;pwd=密码;database=Test2\" providerName=\"System.Data.SqlClient\"/&gt; &lt;/connectionStrings&gt; 创建类 .cs ，设置类的属性、类之间的关联 studentInfo 1234567891011121314151617using System;using System.Collections.Generic;using System.Linq;using System.Web;namespace CodeFirstDemo&#123; public class StudentInfo &#123; public int Id &#123; get; set; &#125; public string stuName &#123; get; set; &#125; public DateTime subTime &#123; get; set; &#125; //建立联系 public virtual ClassInfo classInfo &#123; get; set; &#125; &#125;&#125; classInfo 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.ComponentModel.DataAnnotations;namespace CodeFirstDemo&#123; public class ClassInfo &#123; //Id添加主键标识 [Key] public int Id &#123; get; set; &#125; //数据类型为NVarChar（32），且不可为空 [StringLength(32)] [Required] public string clsName &#123; get; set; &#125; [Required] public DateTime sbuTime &#123; get; set; &#125; //建立联系 public virtual ICollection&lt;StudentInfo&gt; sutdentInfo &#123; get; set; &#125; &#125;&#125; 创建 EF数据操作类 codeFirstDbcontex 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Data.Entity;using System.Data.Entity.ModelConfiguration.Conventions;namespace CodeFirst&#123; public class codeFirstDbcontext:DbContext &#123; //调用父类的构造方法，并传递 配置文件内的 数据库连接字符串 字段 public codeFirstDbcontext() : base(\"name=connStr\") &#123; &#125; public DbSet&lt;ClassInfo&gt; ClassInfo &#123; get; set; &#125; public DbSet&lt;StudentInfo&gt; Student &#123; get; set; &#125; protected override void OnModelCreating(DbModelBuilder modelBuilder) &#123; //实体模型映射成表的时候执行 //移除 将表名设置为实体类型名称的复数版本的约定 //模型名映射在数据库表的时候，可能会出现复数（s） modelBuilder.Conventions.Remove&lt;PluralizingTableNameConvention&gt;(); &#125; &#125;&#125; 执行 12345678codeFirstDbcontext db = new codeFirstDbcontext();//如果 数据库中不存在库，则创建db.Database.CreateIfNotExists();ClassInfo clsInfo = new ClassInfo();clsInfo.clsName = \"16级.NET班\";clsInfo.sbuTime = DateTime.Now;db.ClassInfo.Add(clsInfo);db.SaveChanges(); image ​ （图片不清晰的话请在：浏览器上，鼠标右键，在新标签页中打开图片。即可看到清晰图片） 四、Linq查询和Lambda查询Linq查询Linq查询全部列并降序12345678var userInfoList = from u in db.Users where u.id &gt; 8 orderby u.id ascending //descending降序 select u;foreach (Users userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; Linq分页12345678910int pageIndex = 3;int pageSize = 3;var userInfoList = (from u in db.Users where u.id &gt; 8 orderby u.id ascending //descending降序 select u).Skip((pageIndex - 1) * pageSize).Take(pageSize);foreach (Users userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; Linq查询部分列12345678var userInfoList = from u in db.Users where u.id &gt; 8 //使用匿名类,设置两个字段UName，UPwd select new &#123; UName = u.uName, UPwd = u.uPassword &#125;;foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.UName+\":\"+userInfo.UPwd+\"&lt;hr/&gt;\"); &#125; Lambda查询过滤筛选12345var userInfoList = db.Users.Where&lt;Users&gt;(u =&gt; u.id &gt; 8);foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; Lambda升序排序排序查询对Id进行升序排序排序 1var userInfoList = db.Users.Where&lt;Users&gt;(U =&gt; true).OrderBy&lt;Users, int&gt;(u =&gt; u.id); 对Id进行降序排序排序 12345var userInfoList = db.Users.Where&lt;Users&gt;(U =&gt; true).OrderByDescending&lt;Users, int&gt;(u =&gt; u.id);foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; 在以用户名为前提倒序排序的基础上，如果用户名相同，则使用Id作为依据对用户名相同的用户进行倒序排序 1var userInfoList = db.Users.Where&lt;Users&gt;(u =&gt; true).OrderByDescending(u =&gt; u.uName).ThenByDescending&lt;Users,int&gt;(u =&gt; u.id); Lambda分页查询1234567int pageIndex = 3;int pageSize = 2;var userInfoList = db.Users.Where&lt;Users&gt;(U =&gt; true).OrderByDescending&lt;Users, int&gt;(u =&gt; u.id).Skip&lt;Users&gt;((pageIndex-1)*pageSize).Take&lt;Users&gt;(pageSize);foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125;","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://liruisen.github.io/categories/ASP-NET/"},{"name":"MVC","slug":"ASP-NET/MVC","permalink":"https://liruisen.github.io/categories/ASP-NET/MVC/"}],"tags":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://liruisen.github.io/tags/ASP-NET-MVC/"},{"name":"EF","slug":"EF","permalink":"https://liruisen.github.io/tags/EF/"}]},{"title":"EF框架使用","slug":"2018-3-11 EF框架","date":"2018-03-11T08:58:13.000Z","updated":"2019-06-21T08:28:45.565Z","comments":true,"path":"2018/03/11/2018-3-11 EF框架/","link":"","permalink":"https://liruisen.github.io/2018/03/11/2018-3-11 EF框架/","excerpt":"","text":"本博客所有案例的开发环境为 VS2013 + SQL Server 2012 Entity Framework实体框架简介Entity Framework 实体框架（EF）是ADO.NET的开源对象关系映射（ORM）框架，它是 .NET Framework 的一部分，是一组支持开发面向数据的软件应用程序的技术。微软为实现 .NET 跨平台，将 EF 从 .NET 分离，使EF更加组件化。2016年6月27日，Entity Framework 7作为实体框架核心 1.0 发布，与 ASP.Net Core 1.0 和 .Net Core 1.0 一起发布，重命名为凸显出它是完全重新而不是增量升级，同时，EF7并不会取代EF6。 在EF中的实体数据模型（EDM）由以下三种模型和具有相应文件扩展名的映射文件进行定义。概念架构定义语言文件（.csdl）——定义概念模型存储架构定义语言文件（.ssdl）——定义存储模型映射规范语言文件（.msl）——定义存储模型与概念模型之间的映射M。 实体框架 使用这些基于XML的模型和映射文件将对概念模型中的实体和关系的创建、读取、更新、和删除操作转换为数据源中的等效操作。EDM 甚至支持将概念模型中的实体映射到数据源中的存储过程。 ORM（Object Relational Mapping）框架采用元数据来描述对象一关系映射细节，元数据一般采用XML格式，并且存放在专门的对象一映射文件中。 广义上来说，ORM 可以被认为是 面向对象模型和关系型数据库的数据结构之间的相互转换。 狭义上来说，ORM 可以被认为是，基于关系型数据库的数据存储，实现了一个虚拟的面向对象的数据访问接口。理想情况下，基于这样一个面对对象的接口，持续化一个OO对象应该不需要了解任何关系型数据库存储数据的实现细节。 其他.NET ORM框架: PetaPoco : 与完备的 ORM 框架不同，PetaPoco 更加注重易用性和性能。使用 PataPoco 只需要引入一个C#文件，可以使用强类型的 POCO（Plain Old CLR Object）,并支持 T4 模板生成的类等。此外，由于 PetaPoco 是开源项目，因此添加条件来处理如空间数据等特定情况会很容易。 Dapper :性能方面高于 PetaPoco，速度只稍逊于手工编码的数据访问层（DAL、Data AccessLayer），还有一些对初学者会有帮助的、位于官网上的系列博文和一些独立博文教程。 一、DataFirst使用EF，创建Model （DataFirst） 在解决方案中，创建所使用的项目。例如：ASP网站项目、WinForm窗体项目…… 在新建的项目中，添加 &gt; 新建项 &gt; 数据 &gt; ADO.NET实体数据模型（.edmx） 在新建的.edmx中选择：从数据库生成（DatabaseFirst） 选择新建连接，填写连接数据库 &gt; 填写登录数据库信息 &gt; 选择或输入需要生成模型的数据库名称. 选择需要创建模型的表、视图、存储过程 点击下一步，直接生成（有些电脑可能会出现警告信息，忽视即可）。 ​ （图片不清晰的话请在：浏览器上，鼠标右键，在新标签页中打开图片。即可看到清晰图片） 使用EF创建的内容创建完成后，项目会默认引入两个命名空间：EntityFramework、System.Data.Entity 最外层为.edmx文件，EF模型设计器，展示从数据库创建的模型，包括：表名、属性（表字段）、导航属性（外键、表与表之间的对应关系）、表与表之间1对1、1对多的关系。 Model1.Context.tt、Model.Designer.cs、Model.edmx.diagram、Model1.tt Model1.Context.tt：包含Model1.Context.cs。Model1.Context.tt由T4模板生成，不可更改，Model1.Context.cs继承自DbContext，包括构造方法（继承自父类的构造方法，并在此传递配置文件的数据库连接字符串）、各个表所对应的Dbset&lt;T&gt;类型的自动属性。 Model.Designer.cs：自动生成，无需更改 Model.edmx.diagram：描述edmx文件的元素信息（名称、位置……） Model1.tt：包含生成的Model.cs，自身由T4模板生成，无需修改 使用EF进行增删改查查询123456789StudentMISEntities stu = new StudentMISEntities();//IQueryable&lt;Users&gt; userInfoList=from u in stu.Usersvar userInfoList = from u in stu.Users where u.id == 10 select u;foreach (var item in userInfoList)//EF延迟加载机制，数据用到的时候才去数据库中查询，不用的时候不去查询，提高程序性能&#123; Response.Write(item.uName);&#125; 增加1234567Users userInfo = new Users();userInfo.uName = \"2333\";userInfo.uPassword = \"123\";userInfo.uRole = \"学生\";StudentMISEntities stu = new StudentMISEntities();//创建EF数据操作类实例stu.Users.Add(userInfo);//把数据添加到EF，并添加标记stu.SaveChanges();//把数据保存到数据库 修改12345678910111213141516StudentMISEntities stu = new StudentMISEntities();var userInfoList = from u in stu.Users where u.id == 16 select u;Users userInfo = userInfoList.FirstOrDefault();//返回第一个元素，如果没有的话，返回nullif (userInfo!=null)&#123; userInfo.uPassword = \"12345678\"; stu.Entry&lt;Users&gt;(userInfo).State = System.Data.Entity.EntityState.Modified;//添加修改标记 stu.SaveChanges(); Response.Write(userInfo.uPassword);&#125;else&#123; Response.Write(\"要修改的数据不存在\");&#125; 删除12345678910111213141516 StudentMISEntities stu = new StudentMISEntities(); var userInfoList = from u in stu.Users where u.id == 17 select u;Users userInfo = userInfoList.FirstOrDefault();//返回第一个元素，如果没有的话，返回nullif (userInfo!=null)&#123; //stu.Users.Remove(userInfo); stu.Entry&lt;Users&gt;(userInfo).State = System.Data.Entity.EntityState.Deleted;//添加删除标记 stu.SaveChanges(); Response.Write(\"已删除\");&#125;else&#123; Response.Write(\"要删除的数据不存在\");&#125; 二、ModelFirst 除了支持 DatabaseFirst 外，EF 还支持 ModelFirst 、 CodeFirst，这两种类型不同于DatabaseFirst 先建立好数据库而后映射 Model ， ModelFirst 是通过 Model 映射创建数据库，而 CodeFirst 类似于 ModelFirst， 通过代码逻辑自行创建 Model 并映射数据库，但是不同于 ModelFirst 由 VS 自动创建。 Model先行，通过Model创建数据库 步骤： 在新建的项目中，添加 &gt; 新建项 &gt; 数据 &gt; ADO.NET实体数据模型（.edmx） 在新建的.edmx中选择：空模型（ModelFirst） 在.edmx图形化窗口中，右键 &gt; 新增 &gt; 实体 在新增实体页面 填写: 实体名（表名）、是否创建键属性（是否创建主键）、属性名称、属性类型 &gt; 确定 在.edmx图形化窗口中，在 实体 上右键 &gt; 新增 &gt; 标量属性（表字段） 选中标量属性，按快捷键 F4 或调出属性面板，可以更改标量属性的：类型、名称、长度（必改） 在多个实体，且实体之间有关联的时候，在.edmx图形化设计页面中，右键 &gt; 新建 &gt; 关联 在添加关联页面设置内容（默认即可） 在所有模型创建完毕，在.edmx页面 右键 &gt; 根据模型生成数据库 在 “生成数据库 向导” 页面，新建数据库连接 &gt; 设置连接字符串 &gt; 选择需要创建表的数据库 &gt; 点击下一步 生成数据库向导中，会生成 DDL（数据库设计语言），并另存为 .sql 文件 生成 .sql 文件后，建立的Model并没有映射到数据库引擎中，需要在 .sql 文件中，右键 &gt; 执行，即可。 ​ （图片不清晰的话请在：浏览器上，鼠标右键，在新标签页中打开图片。即可看到清晰图片） 注意事项： 新建 标量属性 后，需要在属性面板对 标量属性的 长度 和 数据类型 进行限制，string 长度即为数据库内字段的 NVarChar 的长度 。 在 .edmx 图形化页面 新建完实体 后，解决方案里面可能没有生成 Model.tt 文件（包含 Model 模型.cs），这时候在 .edmx 图形化页面: 右键 &gt; 添加代码生成项 &gt; 数据 &gt;EF 版本.x DbContext 生成器 &gt; 确定 关于实体更新 需映射数据库更新 更新实体后，VS 在生成的DDL数据库脚本中，是把原先创建好的表全部删除，再重新创建更新后的实体所对应的表，如果原数据表中存在数据，数据也会一并删除。（2）. 在更新数据库时一定要谨慎，做好数据库备份，同时如果只是小的改动（扩大字符长度），手动在数据库里 修改即可，或者仅把更新的sql脚本部分拷贝出来，复制到SQL Server执行 三、CodeFirst先写代码，通过代码创建实体，映射数据库 步骤： 新建项目，在项目里面通过 NuGet程序包 安装EntityFramework（该操作会自动引入EntityFramework以及相对应的命名空间） 在配置文件里面添加连接字符串 123&lt;connectionStrings&gt; &lt;add name=\"CodeFirstDemo\" connectionString=\"server=.;uid=用户;pwd=密码;database=Test2\" providerName=\"System.Data.SqlClient\"/&gt; &lt;/connectionStrings&gt; 创建类 .cs ，设置类的属性、类之间的关联 studentInfo 1234567891011121314151617using System;using System.Collections.Generic;using System.Linq;using System.Web;namespace CodeFirstDemo&#123; public class StudentInfo &#123; public int Id &#123; get; set; &#125; public string stuName &#123; get; set; &#125; public DateTime subTime &#123; get; set; &#125; //建立联系 public virtual ClassInfo classInfo &#123; get; set; &#125; &#125;&#125; classInfo 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.ComponentModel.DataAnnotations;namespace CodeFirstDemo&#123; public class ClassInfo &#123; //Id添加主键标识 [Key] public int Id &#123; get; set; &#125; //数据类型为NVarChar（32），且不可为空 [StringLength(32)] [Required] public string clsName &#123; get; set; &#125; [Required] public DateTime sbuTime &#123; get; set; &#125; //建立联系 public virtual ICollection&lt;StudentInfo&gt; sutdentInfo &#123; get; set; &#125; &#125;&#125; 创建 EF数据操作类 codeFirstDbcontex 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Data.Entity;using System.Data.Entity.ModelConfiguration.Conventions;namespace CodeFirst&#123; public class codeFirstDbcontext:DbContext &#123; //调用父类的构造方法，并传递 配置文件内的 数据库连接字符串 字段 public codeFirstDbcontext() : base(\"name=connStr\") &#123; &#125; public DbSet&lt;ClassInfo&gt; ClassInfo &#123; get; set; &#125; public DbSet&lt;StudentInfo&gt; Student &#123; get; set; &#125; protected override void OnModelCreating(DbModelBuilder modelBuilder) &#123; //实体模型映射成表的时候执行 //移除 将表名设置为实体类型名称的复数版本的约定 //模型名映射在数据库表的时候，可能会出现复数（s） modelBuilder.Conventions.Remove&lt;PluralizingTableNameConvention&gt;(); &#125; &#125;&#125; 执行 12345678codeFirstDbcontext db = new codeFirstDbcontext();//如果 数据库中不存在库，则创建db.Database.CreateIfNotExists();ClassInfo clsInfo = new ClassInfo();clsInfo.clsName = \"16级.NET班\";clsInfo.sbuTime = DateTime.Now;db.ClassInfo.Add(clsInfo);db.SaveChanges(); image ​ （图片不清晰的话请在：浏览器上，鼠标右键，在新标签页中打开图片。即可看到清晰图片） 四、Linq查询和Lambda查询Linq查询Linq查询全部列并降序12345678var userInfoList = from u in db.Users where u.id &gt; 8 orderby u.id ascending //descending降序 select u;foreach (Users userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; Linq分页12345678910int pageIndex = 3;int pageSize = 3;var userInfoList = (from u in db.Users where u.id &gt; 8 orderby u.id ascending //descending降序 select u).Skip((pageIndex - 1) * pageSize).Take(pageSize);foreach (Users userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; Linq查询部分列12345678var userInfoList = from u in db.Users where u.id &gt; 8 //使用匿名类,设置两个字段UName，UPwd select new &#123; UName = u.uName, UPwd = u.uPassword &#125;;foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.UName+\":\"+userInfo.UPwd+\"&lt;hr/&gt;\"); &#125; Lambda查询过滤筛选12345var userInfoList = db.Users.Where&lt;Users&gt;(u =&gt; u.id &gt; 8);foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; Lambda升序排序排序查询对Id进行升序排序排序 1var userInfoList = db.Users.Where&lt;Users&gt;(U =&gt; true).OrderBy&lt;Users, int&gt;(u =&gt; u.id); 对Id进行降序排序排序 12345var userInfoList = db.Users.Where&lt;Users&gt;(U =&gt; true).OrderByDescending&lt;Users, int&gt;(u =&gt; u.id);foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; 在以用户名为前提倒序排序的基础上，如果用户名相同，则使用Id作为依据对用户名相同的用户进行倒序排序 1var userInfoList = db.Users.Where&lt;Users&gt;(u =&gt; true).OrderByDescending(u =&gt; u.uName).ThenByDescending&lt;Users,int&gt;(u =&gt; u.id); Lambda分页查询1234567int pageIndex = 3;int pageSize = 2;var userInfoList = db.Users.Where&lt;Users&gt;(U =&gt; true).OrderByDescending&lt;Users, int&gt;(u =&gt; u.id).Skip&lt;Users&gt;((pageIndex-1)*pageSize).Take&lt;Users&gt;(pageSize);foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125;","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://liruisen.github.io/categories/ASP-NET/"},{"name":"MVC","slug":"ASP-NET/MVC","permalink":"https://liruisen.github.io/categories/ASP-NET/MVC/"}],"tags":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://liruisen.github.io/tags/ASP-NET-MVC/"},{"name":"EF","slug":"EF","permalink":"https://liruisen.github.io/tags/EF/"}]},{"title":"Git系列——2.Git分支","slug":"2018-02-24 Git教程2","date":"2018-02-24T13:43:04.000Z","updated":"2019-05-24T13:35:34.701Z","comments":true,"path":"2018/02/24/2018-02-24 Git教程2/","link":"","permalink":"https://liruisen.github.io/2018/02/24/2018-02-24 Git教程2/","excerpt":"","text":"关于git的学习有一个阶段，如果是从未接触过命令行式开发（Linux、cmd）的萌新的话，建议先去了解下什么是Git，Git有什么用，关于这些网上已经有了很多的介绍了，我也根据我的理解写了一篇关于Git的介绍，点击链接查看 ，同时 Git分支创建、切换分支git branch X分支名X ：创建分支 x分支名x git checkout x分支名x ：切换到 x分支名x git checkout -b x分支名x ：创建并切换到 x分支名x 合并分支前面三条命令就是简单的创建分支和切换分支的方式，在创建过分支后，接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。 git merge x分支名xgit merge 在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点，或者说 我要把这两个父节点本身及它们所有的祖先都包含进来。如图所示： image 我们准备了两个分支，每个分支上各有一个独有的提交。这意味着没有一个分支包含了我们修改的所有内容。咱们通过合并这两个分支来解决这个问题。通过 git merge bugFix 把 bugFix 合并到 master 里（注意我们当前的分支在master上） image 首先，master 现在指向了一个拥有两个父节点的提交记录。假如从 master 开始沿着箭头向上看，在到达起点的路上会经过所有的提交记录。这意味着 master 包含了对代码库的所有修改。 此时将分支切换到 bugFix上，执行git merge master 将master分支合并到 bugFix 上 image 因为 master 继承自 bugFix，Git 什么都不用做，只是简单地把 bugFix 移动到 master 所指向的那个提交记录。现在所有提交记录的颜色都一样了，这代表每一个分支都包含了代码库的所有修改！ git rebase x分支名xRebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。Rebase 的优势就是可以创造更线性的提交历史，如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。 还是准备了两个分支；注意当前所在的分支是 bugFix（星号标识的是当前分支）我们想要把 bugFix 分支里的工作直接移到 master 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。 image 当执行过 git rebase master 后，现在 bugFix 分支上的工作在 master 的最顶端，同时我们也得到了一个更线性的提交序列。注意，提交记录 C3 依然存在（树上那个半透明的节点），而 C3’ 是我们 Rebase 到 master 分支上的 C3 的副本。 image 需要注意的是，此时的master还未更新，还在C2的位置。此时我们只需要checkout master 切换到master分支，再执行 git rebase bugFix。 image 由于 bugFix 继承自 master，所以 Git 只是简单的把 master 分支的引用向前移动了一下而已。此时看起来修改记录只有完整的一条记录！ 参考记录： learngitbranching Git 分支的合并【Learn Git Branching】 廖雪峰Git教程","categories":[{"name":"Git教程","slug":"Git教程","permalink":"https://liruisen.github.io/categories/Git教程/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://liruisen.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://liruisen.github.io/tags/Github/"}]},{"title":"Log4net使用","slug":"2018-4-30 Log4net使用","date":"2018-01-30T13:12:55.000Z","updated":"2019-05-26T08:24:21.349Z","comments":true,"path":"2018/01/30/2018-4-30 Log4net使用/","link":"","permalink":"https://liruisen.github.io/2018/01/30/2018-4-30 Log4net使用/","excerpt":"","text":"Log4Net Log4Net是 apache 公司一款开源的日志记录组件，功能很强大，使用却很简单，本文主要讲述在 ASP.NET MVC中使用 Log4Net。本次开发环境：VS2017、 Log4Net2.0.8 安装可以直接在 VS NuGet 中搜索 Log4Net 进行安装，也可以去官网下载相应的dll文件 Log4net配置在安装过Log4Net后需要对项目进行一些列配置（Web.Config），下面列举两种配置方案，一种是最基本的Log4Net的配置，另外一种是更加详细的配置。 基本配置12345678910111213141516171819202122&lt;configSections&gt; &lt;!--Log4net配置--&gt; &lt;section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\"/&gt; &lt;!--Log4net配置END--&gt;&lt;/configSections&gt; &lt;log4net&gt; &lt;appender name=\"RollingLogFileAppender\" type=\"log4net.Appender.RollingFileAppender\"&gt; &lt;file value=\"test.txt\"/&gt; &lt;appendToFile value=\"true\"/&gt; &lt;maxSizeRollBackups value=\"10\"/&gt; &lt;maximumFileSize value=\"1024KB\"/&gt; &lt;rollingStyle value=\"Size\"/&gt; &lt;staticLogFileName value=\"true\"/&gt; &lt;layout type=\"log4net.Layout.PatternLayout\"&gt; &lt;conversionPattern value=\"%date [%thread] %-5level %logger - %message%newline\"/&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;leval value=\"DEBUG\"/&gt; &lt;appender-ref ref=\"RollingLogFileAppender\"/&gt; &lt;/root&gt; &lt;/log4net&gt; 进一步配置1234567891011121314151617181920212223242526272829303132333435363738&lt;configSections&gt; &lt;!--Log4net配置--&gt; &lt;section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\"/&gt; &lt;!--Log4net配置END--&gt;&lt;/configSections&gt; &lt;log4net&gt; &lt;root&gt; &lt;level value=\"ERROR\"/&gt; &lt;appender-ref ref=\"SysAppender\"/&gt; &lt;/root&gt; &lt;logger name=\"WebLogger\"&gt; &lt;!--这里进一步限制了日志级别，只有大于等于DEBUG的时候才会记录日志--&gt; &lt;level value=\"ERROR\"/&gt; &lt;/logger&gt; &lt;!--指定记录日志的方式，以滚动文件的方式--&gt; &lt;appender name=\"SysAppender\" type=\"log4net.Appender.RollingFileAppender,log4net\" &gt; &lt;!--指定存放日志文件的路径，这里放在App_Data路径下是为了安全--&gt; &lt;param name=\"File\" value=\"App_Data/\" /&gt; &lt;!--日志以追加的方式记录--&gt; &lt;param name=\"AppendToFile\" value=\"true\" /&gt; &lt;param name=\"RollingStyle\" value=\"Date\" /&gt; &lt;!--设置日志名称的生成规则--&gt; &lt;param name=\"DatePattern\" value=\"&amp;quot;Logs_&amp;quot;yyyyMMdd&amp;quot;.txt&amp;quot;\" /&gt; &lt;!--日志名称是否静态：否--&gt; &lt;param name=\"StaticLogFileName\" value=\"false\" /&gt; &lt;!--设置日志内容格式和布局设置--&gt; &lt;layout type=\"log4net.Layout.PatternLayout,log4net\"&gt; &lt;param name=\"ConversionPattern\" value=\"%d [%t] %-5p %c - %m%n\" /&gt; &lt;param name=\"Header\" value=\"&amp;#13;&amp;#10;----------------------header--------------------------&amp;#13;&amp;#10;\" /&gt; &lt;param name=\"Footer\" value=\"&amp;#13;&amp;#10;----------------------footer--------------------------&amp;#13;&amp;#10;\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=\"consoleApp\" type=\"log4net.Appender.ConsoleAppender,log4net\"&gt; &lt;layout type=\"log4net.Layout.PatternLayout,log4net\"&gt; &lt;param name=\"ConversionPattern\" value=\"%d [%t] %-5p %c - %m%n\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;/log4net&gt; 需要注意： &lt;configSections&gt;&lt;/configSections&gt; 配置节中可能有多个组件的配置，这里只显示 log4net 的配置，需要根据自身的情况进行复制，不要全盘复制上去，容易影响自身原本的配置。 &lt;log4net&gt;&lt;log4net&gt; 配置节在 &lt;configSections&gt;&lt;/configSections&gt; 配置节的外部/后部。 第二种配置有一个小问题未能解决：新的错误信息添加到旧的 TXT 文本中时，分割线未能正常显示，结尾线也未能正常显示。通过测试有个猜想，每次程序（网站）启动时，加载该配置，在此次程序运行中，只加载一次分割线，用于区分与上次程序运行时产生的异常信息，此次程序运行中后来的异常信息则不再添加分割线。如果你有其他的配置能解决这个问题或其他想法欢迎在下方留言一起讨论、学习！ 初始化程序在程序最开始的时候加入： 1log4net.Config.XmlConfigurator.Configure(); 项目用的是 ASP.MVC ，所以添加在了 Global.asax 文件中的 Appliction_Start() 方法中。 编写此行代码需要引入 log4net 的命名空间 using log4net; 打印日志信息基本使用在需要打印日志的地方添加： 1LogManager.GetLogger(typeof(Program)).Debug(\"信息\"); 通过 LogManager.GetLogger 传递需要记录的日志类名获得这个类的 ILog （这样在日志文件中就能看到这条日志是哪个类输出的了），然后调用 Debug 方法输出消息。因为一个类内部不止一个地方要打印日志，所以 一般把 ILog 声明为一个 static 字段： 1Private static ILog logger = LogManager.GetLogger(typeof(Test)) 输出错误消息用 ILog.Error 方法，第二个参数可以传递 Exception 对象，如： log.Error(&quot;***错误&quot;+ex)、log.Error(&quot;***错误&quot;,ex) 生产者——消费者模式上面基本使用有一个问题，如果是网站类或大型系统，是很多人同一时间点进行使用，但是每次写入文件的日志信息可能就会有很多条，同一时间内多条日志同时写入文本就会造成 文件并发 问题。这里通过队列的方式来记录日志。 思路：把所有产生的日志信息存放到一个队列里面，然后通过新建一个线程不断的从这个队列里面读取异常信息，然后往日志文件里面写。这个时候就不用担心多个日志信息同时写入日志文件引起的文件并发问题，这就是所谓的生产者——消费者模式。 新建异常信息监控类新建一个类 MyErrorAttribute ，继承自全局异常类 HandleErrorAttribute。 12345678910111213141516171819202122using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.Mvc;namespace SpringLog4netDemo.Models&#123; public class MyErrorAttribute:HandleErrorAttribute &#123; //创建静态队列 public static Queue&lt;Exception&gt; ExceptionQueue = new Queue&lt;Exception&gt;(); public override void OnException(ExceptionContext filterContext) &#123; //将异常信息写入队列中 ExceptionQueue.Enqueue(filterContext.Exception); base.OnException(filterContext); &#125; &#125;&#125; 这样做的目的是通过修改全局异常类拿到触发异常的信息，存储到我们准备好的队列中，用于后面的存储。 在 FilterConfig 类中注册自己的异常信息监控类123456789101112131415using System.Web;using System.Web.Mvc;using SpringLog4netDemo.Models;namespace SpringLog4netDemo&#123; public class FilterConfig &#123; public static void RegisterGlobalFilters(GlobalFilterCollection filters) &#123; // filters.Add(new HandleErrorAttribute()); filters.Add(new MyErrorAttribute()); &#125; &#125;&#125; 在 App_Start 文件夹下 有三个类 ，修改其中的 FilterConfig.cs ，将我们自己写的异常信息监控类注入。 在程序入口添加线程监控在 Global.asax 文件中的 Application_Start() 方法中添加一个线程，用于监控程序运行过程中是否有异常发生。 12345678910111213141516171819202122232425//新建线程用以检测日志ThreadPool.QueueUserWorkItem(o =&gt;&#123; while (true) &#123; if (MyErrorAttribute.ExceptionQueue.Count &gt; 0) &#123; Exception ex = MyErrorAttribute.ExceptionQueue.Dequeue(); if (ex != null) &#123; ILog logger = LogManager.GetLogger(&quot;ErrorMsg&quot;); logger.Error(ex.ToString()); &#125; else &#123; Thread.Sleep(500); &#125; &#125; else &#123; Thread.Sleep(500); &#125; &#125;&#125;); 添加引发异常的方法进行测试在控制器 Home 中故意添加一个引发一场的 Action 的方法 TestLog 进行测试。 1234567public ActionResult TestLog() &#123; int a = 5; int b = 0; int c = a / b; return View(); &#125; 在浏览器进行测试： 打开项目所在目录下的 App_Data文件夹 打开项目所在目录下的 App_Data文件夹，可以看到已经有一个日志文件了： 打开该文件可以看到日志信息已经保存进去 需要注意的地方在浏览器直接请求http://localhost:5252/home/testlog 时，VS会报错暂停，这个时候程序已经中断，但是还并未走到我们新注册的异常信息监控类里面的方法，也就是说异常信息还并未存到队列并且并未存储到本地。 此时VS的页面是这样的： 这个时候不要勾选 “SpringLog4netDemo.dll” 前面的选择框，勾选的话以后在此项目中的此类异常都会被VS屏蔽不再显示，在单独测试 Log4Net 的项目中，这个无所谓，但是如果是比较大的项目的话，这样就比较麻烦了，这个时候直接点击 继续 就可以继续运行了，或者有兴趣的话可以执行下一步查看程序执行的流程。 如果手滑点到那里了怎么办呢？ 打开 调试 &gt; 窗口 &gt; 异常设置 &gt; 选中全部选项 &gt; 检查所有选项中是否有屏蔽条件 &gt; 删除屏蔽条件 Log4Net相关概念Log4Net 有3个重要的组件：loggers , appenders 和 layouts 。这3个组件协同工作使得开发者能够根据信息类型和级别（Level）记录信息，以及在运行时控制信息的格式化和信息的写入位置（如：控制台、文件、内存、数据库等）过滤器帮助这些组件控制追加器 （appender）的行为和把对象转化成字符串的对象渲染。 Appender：可以寄那个日志输出到不同的地方，不同的输出目标对应不同的 Appender，如 RollingFileAppender（滚动文件）、AdoNetAppender（数据库）、SmtpAppender（邮件）等。 level（级别）：标识这条日志信息的重要级别。None &gt; Fatal &gt; ERROR &gt; WARN &gt; DEBUG &gt; INFO &gt;ALL ，设定一个 Level ，那么低于这个 Level 的日志是不会被写入到 Appender 中的。 Log4Net 还可以设定多个 Appender，可以实现同时将日志记录到文件、数据库、发送邮件等；可以设定不同Appdener 的不同 level ，可以实现普通级别都记录到文件、ERROR以上级别都发送邮件；可以实现对不同的类设定不同的 Appender；还可以自定义 Appender ，自己实现将 ERROR 信息发送短信等。 日志框架除了 Log4Net 外，还有 Enterprise Libray 中的 Logging Application Block、Apache 的 CommonLog 以及 NLog 等，使用起来都差不多。 最后附上 Log4Net 的官方文档链接 Apache 官方文档——配置","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://liruisen.github.io/categories/ASP-NET/"},{"name":"MVC","slug":"ASP-NET/MVC","permalink":"https://liruisen.github.io/categories/ASP-NET/MVC/"}],"tags":[{"name":"log4net","slug":"log4net","permalink":"https://liruisen.github.io/tags/log4net/"},{"name":"mvc","slug":"mvc","permalink":"https://liruisen.github.io/tags/mvc/"}]},{"title":"Spring.Net使用","slug":"2018-3-25 Spring-Net使用","date":"2017-11-25T06:20:06.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2017/11/25/2018-3-25 Spring-Net使用/","link":"","permalink":"https://liruisen.github.io/2017/11/25/2018-3-25 Spring-Net使用/","excerpt":"","text":"一、Spring.NET 简单使用 最近用到了 Spring.NET ,不过在第一次使用的时候就遇到了一些问题，打算整理成系列博客，不断的总结和分享。 1. 什么是 Spring.NET ?Spring 框架本是 Java 平台上一个应用非常多的、开源的框架。虽然语言是固定的，但是好的方法应该是通用的，于是 Spring 框架 就被程序员从 Java 平台搬迁到了 .NET 平台。 通过Spring.NET，我们可以用统一且透明的方式来配置应用程序。Spring.NET 的重点是为中间层提供声明式事务管理，以及一个功能齐全的 ASP.NET 扩展框架。Spring.NET 是非侵入式的，代码对框架本身不会产生任何依赖。 Spring.NET 能够提供很多方面的功能，例如：控制反转（英文缩写为IoC）、依赖注入（DI）、面向方面编程(AOP)、数据访问抽象, 以及 ASP.NET 集成等。 Spring.NET 核心： Spring.Core 库是框架的基础, 提供依赖注入功能。Spring NET中大多数类库依赖或扩展了Spring.Core的功能。IObjectFactory接口提供了一个简单而优雅的工厂模式，移除了对单例和一些服务定位stub的必要。允许你将真正的程序逻辑与配置解耦。作为对IObjectFactory 的扩展，IApplicationContext接口也在Spring.Core库中。 2.快速创建第一个使用 Spring.NET 的程序​ 本次开发环境： VS 2017 本次开发项目：.netframework控制台项目 （1）. 使用 Nuget 安装 Spring.core 包 使用 Spring.NET 需要 Spring.Core 库的支持，同时在 Nuget 中安装 Spring.Core 包，会在项目上自动引入相关的引用。 （2）.创建相关文件。 本次创建两个文件：IUserInfo 接口、UserInfo 实体类。使用 Spring 反射创建 UserInfo 类，使用 IUserInfo 接口调用反射创建的类。 1234567891011121314//IUserInfo接口using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Demo&#123; public interface IUserInfo &#123; string ShowMss(); &#125;&#125; 123456789101112131415161718//UserInfo实体类 using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Demo&#123; //实现 IUserInfo接口 public class UserInfo : IUserInfo &#123; public string ShowMss() &#123; return &quot;Hello Spring.NET&quot;; &#125; &#125;&#125; 重要的是在配置节里面的配置 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;!--sectionGroup节点一定要在紧跟着configuration下面第一个添加--&gt; &lt;sectionGroup name=\"spring\"&gt; &lt;!--跟下面Spring.Net节点配置是一一对应关系--&gt; &lt;section name=\"context\" type=\"Spring.Context.Support.ContextHandler,Spring.Core\"/&gt; &lt;section name=\"objects\" type=\"Spring.Context.Support.DefaultSectionHandler,Spring.Core\"/&gt; &lt;/sectionGroup&gt; &lt;/configSections&gt; &lt;!--Spring.Net节点配置--&gt; &lt;spring&gt; &lt;!--容器配置--&gt; &lt;context&gt; &lt;resource uri=\"config://spring/objects\"/&gt; &lt;/context&gt; &lt;objects&gt; &lt;!--objects里面放容器的所有节点--&gt; &lt;description&gt;An example that demonstrates simple Ioc features.&lt;/description&gt;&lt;!--描述--&gt; &lt;!--name 必须要唯一的，type = 类的全名称，所在的程序集--&gt; &lt;object name=\"UserInfo\" type=\"Demo.UserInfo,Demo\"&gt;&lt;/object&gt;&lt;!--咱们刚才创建的UserInfo实体类--&gt; &lt;/objects&gt; &lt;/spring&gt; &lt;startup&gt; &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.6\" /&gt; &lt;/startup&gt;&lt;/configuration&gt; 获取并执行： 1234567891011121314151617181920212223//Program 程序入口类//引用 ： Spring.Context 和 Spring.Context.Support 两个命名空间using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using Spring.Context;using Spring.Context.Support;namespace Demo&#123; class Program &#123; static void Main(string[] args) &#123; IApplicationContext ctx = ContextRegistry.GetContext(); IUserInfo userInfo = (IUserInfo)ctx.GetObject(&quot;UserInfo&quot;); Console.WriteLine(userInfo.ShowMsg()); Console.Read(); &#125; &#125;&#125; 输出结果： 输出结果 注意事项： 必须安装 Spring.core 包，否则缺少环境支持。 需要正确 配置 配置文件： sectionGroup节点一定要在紧跟着configuration下面第一个添加. objects 节点中的 &lt;object&gt;&lt;/object&gt;节点，name=&quot;value&quot; value 值一定要唯一，type =&quot;value1 , value2&quot; 中 value1 是需要反射创建出来的类的全名称，value2 是该类所在的程序集。 反射创建。 二、Spring.NET在MVC中的使用 在ASP.NET MVC中应该如何使用Spring.NET？ 1.先导入dll文件导入以下这些程序节 Spring.core.dll Spring.Web.dll Spring.Web.Extensions.dll Spring.Web.Mvc4.dll Common.Logging.dll 或者直接在 NuGet 中安装 Spring.Web.MVC , 这个方法会直接应用相应的 dll。 2.修改配置信息在大型的项目中，如果把所有的配置信息都放在 Web.config 文件夹，会让该文件显得非常复杂，也不利于维护和修改，这个时候可以将 Spring 的配置节分离到单独的 Xml 文档中。 Web.Config文件相应配置如下 12345678910111213141516171819&lt;configSections&gt; &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt; &lt;section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" /&gt; &lt;!--Spring.NET配置节信息--&gt; &lt;sectionGroup name=\"spring\"&gt; &lt;!--Spring.Net配置--&gt; &lt;section name=\"context\" type=\"Spring.Context.Support.MvcContextHandler, Spring.Web.Mvc4\"/&gt; &lt;/sectionGroup&gt; &lt;!--Spring.NET配置节信息END--&gt; &lt;/configSections&gt; &lt;!--Spring配置信息--&gt; &lt;spring&gt; &lt;!--Spring.Net配置--&gt; &lt;context&gt; &lt;resource uri=\"file://~/Config/controllers.xml\"/&gt; &lt;resource uri=\"file://~/Config/services.xml\"/&gt; &lt;/context&gt; &lt;/spring&gt; &lt;!--Spring配置信息End--&gt; 3.准备分离出来的文件在 Web 项目下新建一个名叫 Config 的文件夹，里面存放 Spring的 配置信息节。 需要注意的是，该文件夹里面的 Xml 文件的复制到输出目录属性需要修改为始终复制。这样做的原因是因为这个Xml文件是静态文件，项目生成解决方案的时候默认是不加载的，只有始终复制才会每次生成的时候加载到 Debug文件夹内。 4.修改controllers.xml中的配置信息在 controllers.xml 文件中，根节点为 Objects 节点， 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;objects xmlns=\"http://www.springframework.net\"&gt; &lt;object type=\"LRS.OA.Web.Controllers.UserInfoController,LRS.OA.Web\" singleton=\"false\"&gt; &lt;property name=\"UserInfoService\" ref=\"UserInfoService\"/&gt; &lt;/object&gt;&lt;/objects&gt; type : 容器内的对象所在的位置（命名空间.类） singleton ：是否指定单例模式，默认是单例模式 propeerty : DI 注入的属性 ref : propeerty 节的属性，指向的是创建的&lt;object&gt;节点名称，也就是创建的其他的对象节点 services.xml 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;objects xmlns=\"http://www.springframework.net\"&gt; &lt;object name=\"UserInfoService\" type=\"LRS.OA.BLL.UserInfoService,LRS.OA.BLL\" singleton=\"false\"&gt; &lt;/object&gt;&lt;/objects&gt; ### ６.修改Global文件 将 MVCApplication 继承自 SpringMvcApplication 。 三、Ioc 和 DIIoc 是控制反转，目的是将实例化类这一步骤从代码中取出，让容器完成自动完成该操作。 DI是依赖注入，是容器在实例化对象时，将该实例的指定属性赋上指定的值。","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://liruisen.github.io/categories/ASP-NET/"},{"name":"MVC","slug":"ASP-NET/MVC","permalink":"https://liruisen.github.io/categories/ASP-NET/MVC/"}],"tags":[{"name":"Spring.Net","slug":"Spring-Net","permalink":"https://liruisen.github.io/tags/Spring-Net/"},{"name":"MVC","slug":"MVC","permalink":"https://liruisen.github.io/tags/MVC/"}]},{"title":"Git系列——1.配置Git","slug":"2017-11-06 配置Git","date":"2017-11-06T03:43:04.000Z","updated":"2019-05-24T10:01:10.204Z","comments":true,"path":"2017/11/06/2017-11-06 配置Git/","link":"","permalink":"https://liruisen.github.io/2017/11/06/2017-11-06 配置Git/","excerpt":"","text":"配置Git 换了电脑，但是新电脑上面并没有安装Git，重新安装后需要进行密钥和用户配置，虽然就没几行命令，但是每次去百度搜索还是费心，写成博客，以后直接找自己写的。 设置user.name和user.email信息：12git config --global user.name \"你的GitHub用户名\"git config --global user.email \"你的GitHub注册邮箱\" 生成密钥文件：1ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" 回车默认不需要设置密码。 把生成的密钥添加到Github上 找到 .ssh 文件夹内的 id_rsa.pub 文件 通常文件目录为 C:\\Users\\Administrator\\.ssh ,用记事本打开 id_rsa.pub 文件，复制文件中的全部内容到剪切板。 把密钥复制到 Github 的配置上 检测Github上的ssh密钥是否添加成功：1ssh git@github.com 只要显示下面这句标识，就证明我们已经的秘钥已经添加成功了。 {8C405715-3228-4A2D-B99B-0AC2DFE363FC}.png 但是，有的时候在将秘钥添加到Github上面以后，可能并不能直接上传或Clone厂库，会弹出来一个窗口进行验证Github（Gitee）的账号密码，输入即可，以后就不需要在此输入了。 Git下载地址 (官网下载太慢，这是腾讯软件中心的下载链接) Git学习链接： 廖雪峰Git教程 stormzhang Git系列教程","categories":[{"name":"Git教程","slug":"Git教程","permalink":"https://liruisen.github.io/categories/Git教程/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://liruisen.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://liruisen.github.io/tags/Github/"}]}]}