{"meta":{"title":"Hexo","subtitle":null,"description":"liruisen'Blog","author":"liruisen","url":"https://liruisen.github.io"},"pages":[{"title":"文章分类","date":"2017-05-27T05:47:40.000Z","updated":"2019-05-20T13:49:55.301Z","comments":false,"path":"tags/index.html","permalink":"https://liruisen.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-03T11:39:03.000Z","updated":"2019-05-20T13:49:55.301Z","comments":false,"path":"categories/index.html","permalink":"https://liruisen.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"恢复HEXO","slug":"2019-5-21恢复Hexo","date":"2019-05-21T03:43:04.000Z","updated":"2019-05-21T05:26:34.858Z","comments":true,"path":"2019/05/21/2019-5-21恢复Hexo/","link":"","permalink":"https://liruisen.github.io/2019/05/21/2019-5-21恢复Hexo/","excerpt":"","text":"恢复HEXO 从GitHub上下载下来源文件 在文件夹内启用 cmd 输入 npm i hexo 执行 hexo clean hexo g hexo s 即可正常显示并恢复","categories":[{"name":"hexo教程","slug":"hexo教程","permalink":"https://liruisen.github.io/categories/hexo教程/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://liruisen.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://liruisen.github.io/tags/Github/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-20T13:49:55.301Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2019/05/20/hello-world/","link":"","permalink":"https://liruisen.github.io/2019/05/20/hello-world/","excerpt":"","text":"this is change txt. 测试批处理命令","categories":[],"tags":[]},{"title":"Nginx使用","slug":"2019-3-29 Nginx","date":"2019-03-29T05:12:55.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2019/03/29/2019-3-29 Nginx/","link":"","permalink":"https://liruisen.github.io/2019/03/29/2019-3-29 Nginx/","excerpt":"为了学习下分布式技术，先学习下 Nginx 反向代理服务器，在学习过程中，顺便还巩固了计算机系统的一些知识，同时，网上关于在 Linux 上配置 Nginx 的教程已经很多了，奈何本人对 Linux 并不是很熟悉，同时现在写的网站大多还是发布在 IIS 上面的，因此本教程主要讲解在 Windows 下配置 Nginx 反向代理服务器。","text":"为了学习下分布式技术，先学习下 Nginx 反向代理服务器，在学习过程中，顺便还巩固了计算机系统的一些知识，同时，网上关于在 Linux 上配置 Nginx 的教程已经很多了，奈何本人对 Linux 并不是很熟悉，同时现在写的网站大多还是发布在 IIS 上面的，因此本教程主要讲解在 Windows 下配置 Nginx 反向代理服务器。 Windows下配置 Nginx 反向代理服务器什么是代理？在学习 Nginx 前，先补充下代理服务器的概念： 代理服务器：一般指的是局域网内部的机器通过代理服务器发送请求到互联网上的服务器，代理服务器一般作用在客户端。应用方面比如：科学上网工具、Nginx。 完整的代理请求流程：客户端首先与代理服务器创建连接，然后根据代理服务器所使用的代理协议请求对目标服务器创建连接或者获得目标服务器的指定资源。代理服务器位于客户端和 Web 服务器之间，扮演中间人的角色，HTTP 的代理服务器既是 Web 服务器又是 Web 客户端，而代理服务器则是介于客户端与 Web 服务器中间的另一台服务器。有了代理服务器之后，客户端发过来的请求不再直接发向 Web 服务器，而是发向了代理服务器，由代理服务器发出请求，取回请求资源后，返回给客户端。 image 正向代理服务器： 位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指向原始服务器，然后代理向原始服务器转交请求并将获取到的内容返回给客户端。客户端必须进行一些特别的设置才能使用正向代理。 反向代理服务器： 在服务端接收客户端的请求，然后把请求分发给具体的服务器进行处理，再将服务器的响应结果返回给客户端。Nginx 就是其中一种反向代理服务器软件。 NginxNginx 是俄罗斯 Igor Sysoev 开发的一款高性能的HTTP和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器，Nginx 本身就可以托管网站，进行HTTP服务处理，也可以作为反向代理服务器使用。 Nginx特点 跨平台：Nginx 可以在大多数 Unix 内核的系统中编译运行，也有 Windows 的移植版本。 配置简单：配置风格和程序开发相近 高并发、非阻塞：复制数据时，磁盘 I/O 的第一阶段是非阻塞的。官方测试能够支撑5万并发连接（实际生产环境中能跑到 2万~3万 并发连接数） 事件驱动：通信机制采用 epoll 模型，支撑更大的并发连接 除此之外，Nginx 还有其他业务上的优势： Nginx 代理和后端 Web 服务器间无需长连接 接收用户请求是异步的，即先将用户的请求全部接收下来，再一次性发送后端 Web 服务器，极大减轻后端Web 服务器的压力 发送响应报文时，一遍接收来自后端 Web 服务器的数据，一边发送个客户端 网络依赖性低。Nginx 对网络的依赖程度非常低，从理论上来说，只要能够 Ping 通就可以实施负载均衡，而且可以有效区分内网和外网流量。 支持服务器检测。Nginx 能够根据应用服务器处理页面返回的状态码，超时信息等检测服务器是否出现故障，并及时返回错误的请求，重新提交到其他节点上。 Nginx事件处理机制通信机制采用epoll模型，支持更大的并发连接。 master/worker 结构：一个 master 进程，生成多个 worker 进程 内存消耗小：并发处理大并发的请求，内存消耗非常小。在3万并发连接下，开启的1个 Nginx 进程才消耗150MB 内存（15MB*10=150MB） 成本低：Nginx 作为开源软件，可以免费使用，而硬件负载均衡交换机则需要十多万甚至几十万人民币 内置的健康检查功能：如果 Nginx Proxy 后端的某台 Web 服务器宕机了，就不会影响前端访问 节省带宽：支持GZIP压缩，可以添加浏览器本地缓存的Header头。 稳定性高：用于反向代理，宕机的概率微乎其微。 Nginx 内部模型 Nginx是以多进程的方式来工作的。当然 nginx 也是支持多线程的方式的,仅仅是我们主流的方式还是多进程的方式，也是nginx的默认方式。 nginx 採用多进程的方式有诸多优点。 nginx 在启动后，会有一个master进程和多个 worker 进程。master 进程主要用来管理 worker 进程，包括：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的执行状态,当 worker 进程退出后(异常情况下)，会自己主动又一次启动新的 worker 进程。而主要的网络事件。则是放在 worker 进程中来处理了 。多个 worker 进程之间是对等的，他们同等竞争来自 client 的请求。各进程互相之间是独立的 。一个请求，仅仅可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其他进程的请求。 worker 进程的个数是能够设置的，一般我们会设置与机器 cpu 核数一致，这里面的原因与 nginx 的进程模型以及事件处理模型是分不开的 。 Master 接收到信号以后如何进行处理（./nginx -s reload ）? 首先 master 进程在接到信号后，会先又一次载入配置文件。然后再启动新的进程。并向全部老的进程发送信号，告诉他们能够光荣退休了。 新的进程在启动后，就開始接收新的请求，而老的进程在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的全部未处理完的请求处理完毕后，再退出 . worker 进程又是如何处理请求的呢？我们前面有提到。worker 进程之间是平等的。每一个进程，处理请求的机会也是一样的。当我们提供 80 port 的 http 服务时。一个连接请求过来，每一个进程都有可能处理这个连接，怎么做到的呢？首先，每一个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面。先建立好须要 listen 的 socket 之后。然后再 fork 出多个 worker 进程，这样每一个 worker 进程都能够去 accept 这个 socket (当然不是同一个 socket ，仅仅是每一个进程的这个 socket 会监控在同一个 ip 地址与 port，这个在网络协议里面是同意的)。一般来说。当一个连接进来后。全部在 accept 在这个 socket 上面的进程。都会收到通知。而仅仅有一个进程能够 accept 这个连接，其他的则 accept 失败，这是所谓的惊群现象。 当然，nginx 也不会视而不见，所以 nginx 提供了一个 accept_mutex 这个东西，从名字上。我们能够看这是一个加在 accept 上的一把共享锁。有了这把锁之后，同一时刻，就仅仅会有一个进程在 accpet 连接，这样就不会有惊群问题了。accept_mutex 是一个可控选项，我们能够显示地关掉。默认是打开的。当一个 worker 进程在 accept 这个连接之后，就開始读取请求。解析请求。处理请求，产生数据后，再返回给 client，最后才断开连接，这样一个完整的请求就是这种了。我们能够看到，一个请求。全然由 worker 进程来处理。并且仅仅在一个 worker 进程中处理。 nginx 采用这种进程模型有什么优点呢？採用独立的进程，能够让互相之间不会影响，一个进程退出后，其他进程还在工作，服务不会中断，master 进程则非常快又一次启动新的 worker 进程。当然，worker 进程的异常退出。肯定是程序有 bug 了，异常退出。会导致当前 worker 上的全部请求失败，只是不会影响到全部请求，所以减少了风险。当然，优点还有非常多，大家能够慢慢体会。 有人可能要问了。nginx 採用多 worker 的方式来处理请求，每一个 worker 里面仅仅有一个主线程，那能够处理的并发数非常有限啊。多少个 worker 就能处理多少个并发。何来高并发呢？非也，这就是 nginx 的高明之处，nginx 採用了异步非堵塞的方式来处理请求。也就是说，nginx 是能够同一时候处理成千上万个请求的 .对于 IISserve r每一个请求会独占一个工作线程。当并发数上到几千时，就同一时候有几千的线程在处理请求了。 这对操作系统来说。是个不小的挑战，线程带来的内存占用非常大。线程的上下文切换带来的 cpu 开销非常大。自然性能就上不去了。而这些开销全然是没有意义的。 我们之前说过，推荐设置 worker 的个数为 cpu 的核数，在这里就非常 easy 理解了，很多其他的 worker 数，仅仅会导致进程来竞争 cpu 资源了，从而带来不必要的上下文切换。 并且，nginx 为了更好的利用多核特性，提供了 cpu 亲缘性的绑定选项。我们能够将某一个进程绑定在某一个核上。这样就不会由于进程的切换带来 cache 的失效。 Nginx应用场景负载均衡技术在现有网络结构智商提供了一种廉价、有效、透明的方法来扩展网络设备和服务器的带宽 、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。它有两方面的含义：首先，大量并发的访问或数据流量分担到多台节点设备上分别处理，减少用户等待相应的时间；其次，单个负载均衡的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后将结果汇总，返回给用户，系统处理能力得到大幅度提高。 Nginx的使用本文只讲解 Windows 版本的 Nginx，Linux 上的 Nginx 以后再讲 到官方网站下载 Windows 版本。下载地址 解压后，文件结构如下 修改配置文件 。打开目录 Conf，找到 nginx 核心的配置文件 nginx.conf 进行修改。 启动服务：直接运行 nginx.exe 即可。 停止服务： 启动任务管理器直接关闭进程 在 CMD 中，进入 nginx.exe 所在目录，输入 nginx -s stop 重新加载配置： 重启 nginx.exe 在 CMD 中，进入 nginx.exe 所在目录，输入 nginx -s reload Nginx的常见配置常见配置 Nginx集群案例最后一步，通过一个 Demo 来演示使用 Nginx+IIS 服务器来搭建服务器集群 为了演示，创建了3个 Web 项目，然后分别部署在三台IIS服务器上，当然这个 Demo 并未做详细的业务与逻辑，只以站点的内容让其稍微有点不同以区分。而生产环境则是把相同的 Web 项目部署在不同的IIS服务器上面。 创建项目 新建一个空的 MVC 项目 添加控制器 Home 添加 Index 视图 1234@&#123; ViewBag.Title = \"Index\"&#125;&lt;h2&gt;这是第1个网站&lt;/h2&gt; 发布站点1 将发布好的站点中的View\\Home\\Index.cshtml内容修改为： 1234@&#123; ViewBag.Title = \"Index\"&#125;&lt;h2&gt;这是第2个网站&lt;/h2&gt; 获得第二个站点，并发布 继续第5步，修改内容为： 1234@&#123; ViewBag.Title = \"Index\"&#125;&lt;h2&gt;这是第3个网站&lt;/h2&gt; 获得第三个站点，并发布 修改 Nginx 的配置文件 nginx.conf 在 http 节点上添加代码如下： 1234567upstream netittest.com&#123; #服务器集群名字 server www.barteam.cn:8085 weight=1; server superforest.cn:8085 weight=1; server 127.0.0.1:8087 weight=1; server 127.0.0.1:8089 weight=1;&#125; 修改 http 节点上的 server 节点、 location 节点 1234567891011 server &#123; listen 8088; #监听端口 server_name superforest.cn；#你服务器的节点，如果是本地的话为127.0.0.1 location / &#123; #root html; #index index.html index.htm; proxy_pass http://netittest.com; proxy_redirect default; ·············&#125; 启动 nginx 服务，以管理员身份，运行 CMD 窗口，进入 nginx 所在目录，启动 nginx.exe 1C:\\Program Files (x86)\\nginx-1.14.2&gt;nginx.exe 在浏览器输入你上面 server 中配置的 server_name 和 listen（nginx 配置文件中配置的服务器监听终结点），然后刷新浏览器，结果如下： image 请注意，浏览器地址框一直未变。 其实现原理如下图所示 image 这个 Demo 只是为了简单演示下关于通过 Nginx 搭建集群的效果，如果换到生产环境的话，需要配置的就不止上面这些，关于其他详细的配置可以查看前文中的链接，或去百度查找其他博客。 参考资料 《ASP.NET MVC 企业级实战》 Nginx内部模型 Nginx常见配置","categories":[{"name":"分布式","slug":"分布式","permalink":"https://liruisen.github.io/categories/分布式/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://liruisen.github.io/tags/Windows/"},{"name":"Nginx","slug":"Nginx","permalink":"https://liruisen.github.io/tags/Nginx/"}]},{"title":"art-template 踩坑","slug":"2019-3-12 art-template","date":"2019-03-11T03:12:55.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2019/03/11/2019-3-12 art-template/","link":"","permalink":"https://liruisen.github.io/2019/03/11/2019-3-12 art-template/","excerpt":"项目需要使用 art-template 进行前端渲染，本想直接使用 Vue ，不过项目渲染不多，还是学习下 art-template吧，提前踩踩坑，避免用在项目上的时候出现问题。用的时候了解到 art-template 好像是腾讯团队开发维护的，感觉文档要糟糕，不出所料在文档上遇到一些问题。","text":"项目需要使用 art-template 进行前端渲染，本想直接使用 Vue ，不过项目渲染不多，还是学习下 art-template吧，提前踩踩坑，避免用在项目上的时候出现问题。用的时候了解到 art-template 好像是腾讯团队开发维护的，感觉文档要糟糕，不出所料在文档上遇到一些问题。 art-template使用笔记art-template 是前端的一个高性能 JavaScript 模板引擎，它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能。 通过下面一张图可以大致了解下 art-template 与其他方式渲染HTML页面的性能比较： 具体跟 Vue、React 这些前端主流框架比较的性能，官方并未给出数据，但是我认为只比较页面渲染能力的话，应该相差不多， Vue、React 是一整套的前端解决方案，而 art-template 只是一个 js模板引擎，二者定位和功能不同，不做详细比较，猜测 art-template 同样是使用虚拟 DOM 的方式进行页面渲染，否则能达到这样的性能，着实不容易。就学习而言，如果学习过 Vue、React，学这个非常简单，反过来学会 art-template 对学习 Vue、React也有一定帮助。 在网上查询资料的时候，发现 art-template 好像是腾讯团队开发开源的，了解到这个情况的时候，心中少不了吐槽，不可否认东西确实好用，但是架不住腾讯团队写的文档烂啊！！腾讯团队什么时候能在文档上面长点心，学学隔壁的阿里。废话不多说了，简单写下容易遇到的问题。 初始化问题关于 art-template 模板编写语法很简洁； template 对象的初始化也非常简单，只有两行代码， 模板编写： 12345678910111213141516171819&lt;script id=\"art-template\" type=\"text/html\"&gt;&lt;table&gt; /******/ &lt;tbody&gt; &#123;&#123;each classInfoList&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Teacher&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Remark&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"&#123;&#123;$value.Uri&#125;&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/script&gt; template对象初始化： 12var html = template(\"art-template\", datas);document.getElementById('app').innerHTML = html; &quot;art-template&quot; 是定义好的模板的 id datas 是需要渲染的数据 JS执行时间、顺序问题在网上找到的 Demo 大多都是在 js 里面写一个假数据，用定义好的数据去初始化 template 对象，例如： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;basic-demo&lt;/title&gt; &lt;script src=\"../dist/template.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script id=\"test\" type=\"text/html\"&gt; &#123;&#123;if isAdmin&#125;&#125; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &#123;&#123;each list as value i&#125;&#125; &lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &#123;&#123;/if&#125;&#125; &lt;/script&gt; &lt;script&gt; var data = &#123; title: '基本例子', isAdmin: true, list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他'] &#125;; var html = template('test', data); document.getElementById('content').innerHTML = html; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 因为以前主要使用 Vue ，Vue 是有动态渲染，但是忘记了这个并没有提到是动态渲染，同时项目开发时，数据大多通过 Ajax 从后台获取，因此在开始时，将 template 对象初始化放在了 ajax 回调函数外，因为 ajax 请求数据需要花费时间，同时js代码跟后台代码执行顺序不同，并不是按行数依次执行，所以前期导致一直渲染失败。应注意 js 代码执行顺序和执行时间的问题。 完整ajax代码如下： 1234567891011121314151617var datas = &#123; title: \"\", classInfoList: []&#125;$.ajax(&#123; type: \"GET\", dataType:\"JSON\", url: \"/ClassHandler.ashx\", success: function (data) &#123; //原生JS序列化JSOn //datas.classInfoList = JSON.parse(data).classInfoList; datas.classInfoList = data.classInfoList; datas.title =data.title; html = template(\"art-template\", datas); document.getElementById('app').innerHTML = html; &#125;&#125;) template数据初始化问题在上面也看到，序列化 template 对象一共传了两个参数，一个是模板的 Id，另外一个是数据。 但是这个数据有个一问题，如果返回回来的 JSON 数据是类似数组数据的话，是没有办法直接渲染的，如： 12345678910111213141516171819[&#123; \"Id\": 0, \"Name\": \"班级0\", \"Teacher\": \"教师0\", \"Remark\": \"这是班级0的简介\", \"Uri\": \"/deleteClass.ashx?id=0\"&#125;, &#123; \"Id\": 1, \"Name\": \"班级1\", \"Teacher\": \"教师1\", \"Remark\": \"这是班级1的简介\", \"Uri\": \"/deleteClass.ashx?id=1\"&#125;, &#123; \"Id\": 2, \"Name\": \"班级2\", \"Teacher\": \"教师2\", \"Remark\": \"这是班级2的简介\", \"Uri\": \"/deleteClass.ashx?id=2\"&#125;] 这个样子是没有办法直接进行渲染，需要对数据如上述代码块包装，才能正常渲染。 如果返回 JSON 数据为： 12345678910111213141516171819202122&#123; \"classInfoList\": [&#123; \"Id\": 0, \"Name\": \"班级0\", \"Teacher\": \"教师0\", \"Remark\": \"这是班级0的简介\", \"Uri\": \"/deleteClass.ashx?id=0\" &#125;, &#123; \"Id\": 1, \"Name\": \"班级1\", \"Teacher\": \"教师1\", \"Remark\": \"这是班级1的简介\", \"Uri\": \"/deleteClass.ashx?id=1\" &#125;, &#123; \"Id\": 2, \"Name\": \"班级2\", \"Teacher\": \"教师2\", \"Remark\": \"这是班级2的简介\", \"Uri\": \"/deleteClass.ashx?id=2\" &#125;], \"title\": \"软件学院班级列表\"&#125; 可以直接初始化 template 对象，并进行渲染（模板不变） 1234567891011&lt;script&gt; $.ajax(&#123; type: \"GET\", dataType:\"JSON\", url: \"/ClassHandler.ashx\", success: function (data) &#123; html = template(\"art-template\", data); document.getElementById('app').innerHTML = html; &#125; &#125;)&lt;/script&gt; template 对象初始化需注意地方API：template(filename, content) 根据模板名渲染模板。 参数： {string} filename {Object,string} content 返回值： 如果 content 为 Object，则渲染模板并返回 string 如果 content 为 string，则编译模板并返回 function 浏览器版本无法加载外部文件，filename 为存放模板的元素 id 因为渲染的时候，数据大多从后台获取，后台返回的数据可能为字符串或JSON，如果第二个参数（content）传进来的是字符串的话，没有报错，但是渲染会失败，渲染结果如下： image 因此，需注意 template 初始化赋值时，数据格式是否正确。 渲染问题each 循环渲染问题关于循环的语法，官方文档上写的很简洁： image 默认在遍历 target 时，有两个值，value和index，其中 value 是单个对象值，index 是下标。 根据文档所写，我把 123456789101112&#123;&#123;each classInfoList&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Teacher&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$value.Remark&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;&#123;$value.Uri&#125;&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&#123;&#123;/each&#125;&#125; 修改为： 123456789101112&#123;&#123;each classInfoList val key&#125;&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;$key+1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$val.Id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$val.Name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$val.Teacher&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$val.Remark&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;&#123;$val.Uri&#125;&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&#123;&#123;/each&#125;&#125; 浏览器在渲染的时候就报错了： image 至今不清楚，是我没领会文档说明，还是 art-template 团队忘了维护文档了。 结语本文只是 art-template js模板引擎的简单使用，还有其他几个接口、方式没有逐一介绍，在我看来这些已经能够满足基本的开发使用，至于更加复杂的渲染、渲染切换，Vue 比 art-template 省心。如有兴趣继续研究 art-template ，附上官方文档及参考博客链接。 参考文档： art-template 官方文档 art-template官方API文档 js模板引擎-art-template常用总结","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"}],"tags":[{"name":"art-template","slug":"art-template","permalink":"https://liruisen.github.io/tags/art-template/"},{"name":"JS引擎模板","slug":"JS引擎模板","permalink":"https://liruisen.github.io/tags/JS引擎模板/"}]},{"title":"问题与解决方案汇总（1）","slug":"2019-1-30 0.前端bootstrap表格与axios请求","date":"2019-01-30T08:58:13.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2019/01/30/2019-1-30 0.前端bootstrap表格与axios请求/","link":"","permalink":"https://liruisen.github.io/2019/01/30/2019-1-30 0.前端bootstrap表格与axios请求/","excerpt":"开发过程中少不了踩坑，记录下各个踩坑的详情，给自己带来便利的同时，也能给其他人提供或多或少的帮助，这就再好不过了。第一期有两个问题，分别是 Bootstrap 表格中插入按钮导致表格自适应失效 ，以及 axios.js 在 Vue.js 的搭配使用过程中的 this 无法指向 Vue 对象 。","text":"开发过程中少不了踩坑，记录下各个踩坑的详情，给自己带来便利的同时，也能给其他人提供或多或少的帮助，这就再好不过了。第一期有两个问题，分别是 Bootstrap 表格中插入按钮导致表格自适应失效 ，以及 axios.js 在 Vue.js 的搭配使用过程中的 this 无法指向 Vue 对象 。 问题1 ： Bootstrap 表格中插入按钮导致表格自适应失效问题描述：昨天在写前台的时候，把前台的表格使用了Bootstrap美化了一下，立刻漂亮了很多，然后随手将表格里面的两个 a 标签加上了btn btn-danger btn-sm 、btn btn-success btn-sm 两个类，效果增强了很多，如图： image 今天在写前台代码的时候，突然发现表格中的文字的行距不再居中对齐了，文本位置偏上。 image 思考过程： 应该不是什么太大的问题吧，去问下前端比较厉害的同学吧，发了信息，该过年了比较忙，没有来得及回复。 直接去调整表格里面文字的 lin-hight 吧，直接去浏览器定位到单元格的类，然后回编辑器进行修改。 解决问题的思路： 想如果适应到其他设备上，写固定值的行高会不会不合适？但是好像又没有什么好的解决方案，但是灵光一动想到（吃饱了以后想到），a 标签是行内元素，button 是块级元素，给 a 标签添加上 btn 类的时候，是否将 a 标签由行内元素转换成块级元素？实验后发现，想法正确。不添加 btn 类只是单独的 a 标签，这个时候表格的自适应还是有效的；将 a 标签换成 button 标签后，表单的自适应失效。 image 既然发现了问题所在，那就容易解决了，将添加过 btn btn-danger btn-sm 的 a 标签由块级元素重新转换成行内元素就行了。 考虑到其他地方添加 btn 类的内容不需要转换成行内元素，因此这里解决的办法是在内联样式表中添加上这样一行，或者是写一个类，只有下面一条样式，然后将这个类放在 class 属性的最后面。 12345678910.btn-sm&#123; display:inline; &#125;OR.ainline&#123; display:inline;&#125;&lt;a class=\"btn btn-success btn-sm ainline\" v-on:click=\"\"&gt;另一种方法&lt;/a&gt; 如果你有更好的解决方案，请一起沟通。 发现问题产生原因所在，和解决问题一样重要。 问题2：axios.js 在 Vue.js 的配合中的 this以前在使用 Vue 向后台发送 ajax 请求的时候，使用的是 vue-resource.js ，不过现在 Vue 已经停止更新 vue-resource ，转而建议使用 axios.js ，新手注定多踩坑。 问题描述：在 vue-resource 向后台发送 ajax 的时候，只需要简单的一行 js 代码就能搞定，当然 axios.js 也是很简单的一行就能搞定，但是问题出在了接收数据的环节。下面请看 vue-resource 的解决方案。 12345678910111213var user = new Vue(&#123;el: \"#app\",data: &#123; userListApiUrl: '/Home/UserList', jsondata: []&#125;,methods: &#123; getRequest: function () &#123; this.$http.get(this.userListApiUrl).then(function (res) &#123; this.jsondata = res.body; &#125;) &#125;&#125;) 其中，在 then(function (res){} 函数中，直接就能把从后台返回的数据赋值给 this.jsondata ，很简洁也很简单。 但是 axios 按照这个格式去写的话，也能拿到后台返回的数据，但是就是不能将返回的数据 赋值给 this.jsondata (axios 的语法不再前面添加 this) 12345678910111213var user = new Vue(&#123;el: \"#app\",data: &#123; userListApiUrl: '/Home/UserList', jsondata: []&#125;,methods: &#123; getRequest: function () &#123; axios.get(this.userListApiUrl).then(function (res) &#123; this.jsondata = res.data; &#125;) &#125;&#125;) 思考过程：出现这样的问题一直百思不得其解，难不成只能一直使用 vue-resource ？ 向困难低头不是我的作风。羊毛出在羊身上，从浏览器上寻找问题。 通过对 js 代码打断点发现了一个现象： image 这个 this 好像指向了 Window 对象，回头查看两段代码，发现了区别： 12345678// vue-resourcethis.$http.get(this.userListApiUrl).then(function (res) &#123; this.jsondata = res.body;&#125;)// axiosaxios.get(this.userListApiUrl).then(function (res) &#123; this.jsondata = res.data;&#125;) vue-resource 在使用前加了 this，根据代码所在的位置，可以判断出第一个和第二个 this 指向的对象都是 user 这个 Vue 对象，因此该段代码的作用域还是在new Vue() 中，这样的话里面的第三个 this 指向的也是 user 对象。 同时， vue-resource 能在前面添加 this 说明 vue-resource 集成在了 Vue 框架中，因此需要添加 this. 才能正常使用，但是在 axios 有没有集成到 Vue 框架中我并不知道啊（事后实验发现在 Vue 中通过 this 并不能访问到 axios 也可能是我的操作不对），官方的Demo就直接这样写了也没见加 this，因此在 axios 代码段中，第一个 this 因为作用域的原因，指向的是 user 这个 Vue 对象，但是里面的 this 因为没有集成到 Vue 同时 axios.js 是独立的 js 文件，作用域为顶级作用域，因此第二个 this 指向的是 Window 这个对象。 解决过程：既然发现问题出在哪里了，那就比较容易解决了，既然 axios 内部的作用域是顶级作用域，那么 user 对象就和其处在同一个作用域中了，修改后的代码如下： 12345678910111213var user = new Vue(&#123;el: \"#app\",data: &#123; userListApiUrl: '/Home/UserList', jsondata: []&#125;,methods: &#123; getRequest: function () &#123; axios.get(this.userListApiUrl).then(function (res) &#123; user.jsondata = res.data; &#125;) &#125;&#125;) 同时，根据 Vue 的生命周期钩子函数的执行顺序，在此位置访问 user 应该是没有问题的。 问题解决。 如果你有其他的看法，一起交流。 多看，多实践。","categories":[{"name":"问题与解决方案","slug":"问题与解决方案","permalink":"https://liruisen.github.io/categories/问题与解决方案/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://liruisen.github.io/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"https://liruisen.github.io/tags/axios/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://liruisen.github.io/tags/Bootstrap/"},{"name":"前端问题","slug":"前端问题","permalink":"https://liruisen.github.io/tags/前端问题/"}]},{"title":"GitHub：无限制的免费私人仓库","slug":"2019-1-8 GitHub私人仓库免费","date":"2019-01-07T08:58:13.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2019/01/07/2019-1-8 GitHub私人仓库免费/","link":"","permalink":"https://liruisen.github.io/2019/01/07/2019-1-8 GitHub私人仓库免费/","excerpt":"","text":"新的GitHub：无限制的免费私人仓库 Github 2018年6月4日微软发布公告称，微软将以 75亿美元 的微软股票收购 GitHub ，因为过往业界对微软闭源的固有观念，使得业内并不看好 GitHub 被收购后的未来，以至于出现了一批把项目从 GitHub 迁移到其他平台的热点，但是微软已经不是十年前那个微软，如今 GitHub 也已不再是收购前的 GitHub 了。 GitHub 被收购前，国内拉取 GitHub 的仓库及推送 GitHub的仓库，速度基本上并不快，以百兆宽带来说，下行速度基本不超过 1Mb/s ，上行速度不超过 200kb/s ，收购后第一个可喜的变化就是国内地区的网络服务得到了极大的提升，上行和下行速度基本不会出现像百度网盘那样限速一样的现象，现在的速度很大都是基于带宽。 今天， GitHub 发了一篇博客，宣布了 GitHub 的又一改变：无限制的免费私有存储库。 每个存储库最多可以免费使用三个协作者，对于大部分只有自己进行代码提交的开发者来说，已经够用了！ 在此之前，如果想要使用 GitHub 的免费私人仓库，有两种途径，每月支付 $7 或认证为学生账户，对非学生群体的开发者来说，每月 7美刀 的价格并不是很亲民，同时国内其他代码托管平台提供的免费私人仓库服务，也给开发者提供了不同的选择。 今天 Github 的改变固然让开发者很是欣喜，不过这一改变也会挤压国内其他代码托管平台的生存空间，具体利弊因人而异，GitHub 后续如何，敬请期待。 Github该篇博客链接","categories":[{"name":"随笔","slug":"随笔","permalink":"https://liruisen.github.io/categories/随笔/"},{"name":"新闻","slug":"随笔/新闻","permalink":"https://liruisen.github.io/categories/随笔/新闻/"}],"tags":[{"name":"新闻","slug":"新闻","permalink":"https://liruisen.github.io/tags/新闻/"}]},{"title":"Log4net使用","slug":"Log4net使用","date":"2018-01-30T13:12:55.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2018/01/30/Log4net使用/","link":"","permalink":"https://liruisen.github.io/2018/01/30/Log4net使用/","excerpt":"","text":"##Log4Net Log4Net是 apache 公司一款开源的日志记录组件，功能很强大，使用却很简单，本文主要讲述在 ASP.NET MVC中使用 Log4Net。本次开发环境：VS2017、 Log4Net2.0.8 安装可以直接在 VS NuGet 中搜索 Log4Net 进行安装，也可以去官网下载相应的dll文件 Log4net配置在安装过Log4Net后需要对项目进行一些列配置（Web.Config），下面列举两种配置方案，一种是最基本的Log4Net的配置，另外一种是更加详细的配置。 基本配置12345678910111213141516171819202122&lt;configSections&gt; &lt;!--Log4net配置--&gt; &lt;section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\"/&gt; &lt;!--Log4net配置END--&gt;&lt;/configSections&gt; &lt;log4net&gt; &lt;appender name=\"RollingLogFileAppender\" type=\"log4net.Appender.RollingFileAppender\"&gt; &lt;file value=\"test.txt\"/&gt; &lt;appendToFile value=\"true\"/&gt; &lt;maxSizeRollBackups value=\"10\"/&gt; &lt;maximumFileSize value=\"1024KB\"/&gt; &lt;rollingStyle value=\"Size\"/&gt; &lt;staticLogFileName value=\"true\"/&gt; &lt;layout type=\"log4net.Layout.PatternLayout\"&gt; &lt;conversionPattern value=\"%date [%thread] %-5level %logger - %message%newline\"/&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;leval value=\"DEBUG\"/&gt; &lt;appender-ref ref=\"RollingLogFileAppender\"/&gt; &lt;/root&gt; &lt;/log4net&gt; 进一步配置1234567891011121314151617181920212223242526272829303132333435363738&lt;configSections&gt; &lt;!--Log4net配置--&gt; &lt;section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\"/&gt; &lt;!--Log4net配置END--&gt;&lt;/configSections&gt; &lt;log4net&gt; &lt;root&gt; &lt;level value=\"ERROR\"/&gt; &lt;appender-ref ref=\"SysAppender\"/&gt; &lt;/root&gt; &lt;logger name=\"WebLogger\"&gt; &lt;!--这里进一步限制了日志级别，只有大于等于DEBUG的时候才会记录日志--&gt; &lt;level value=\"ERROR\"/&gt; &lt;/logger&gt; &lt;!--指定记录日志的方式，以滚动文件的方式--&gt; &lt;appender name=\"SysAppender\" type=\"log4net.Appender.RollingFileAppender,log4net\" &gt; &lt;!--指定存放日志文件的路径，这里放在App_Data路径下是为了安全--&gt; &lt;param name=\"File\" value=\"App_Data/\" /&gt; &lt;!--日志以追加的方式记录--&gt; &lt;param name=\"AppendToFile\" value=\"true\" /&gt; &lt;param name=\"RollingStyle\" value=\"Date\" /&gt; &lt;!--设置日志名称的生成规则--&gt; &lt;param name=\"DatePattern\" value=\"&amp;quot;Logs_&amp;quot;yyyyMMdd&amp;quot;.txt&amp;quot;\" /&gt; &lt;!--日志名称是否静态：否--&gt; &lt;param name=\"StaticLogFileName\" value=\"false\" /&gt; &lt;!--设置日志内容格式和布局设置--&gt; &lt;layout type=\"log4net.Layout.PatternLayout,log4net\"&gt; &lt;param name=\"ConversionPattern\" value=\"%d [%t] %-5p %c - %m%n\" /&gt; &lt;param name=\"Header\" value=\"&amp;#13;&amp;#10;----------------------header--------------------------&amp;#13;&amp;#10;\" /&gt; &lt;param name=\"Footer\" value=\"&amp;#13;&amp;#10;----------------------footer--------------------------&amp;#13;&amp;#10;\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=\"consoleApp\" type=\"log4net.Appender.ConsoleAppender,log4net\"&gt; &lt;layout type=\"log4net.Layout.PatternLayout,log4net\"&gt; &lt;param name=\"ConversionPattern\" value=\"%d [%t] %-5p %c - %m%n\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;/log4net&gt; 需要注意： &lt;configSections&gt;&lt;/configSections&gt; 配置节中可能有多个组件的配置，这里只显示 log4net 的配置，需要根据自身的情况进行复制，不要全盘复制上去，容易影响自身原本的配置。 &lt;log4net&gt;&lt;log4net&gt; 配置节在 &lt;configSections&gt;&lt;/configSections&gt; 配置节的外部/后部。 第二种配置有一个小问题未能解决：新的错误信息添加到旧的 TXT 文本中时，分割线未能正常显示，结尾线也未能正常显示。通过测试有个猜想，每次程序（网站）启动时，加载该配置，在此次程序运行中，只加载一次分割线，用于区分与上次程序运行时产生的异常信息，此次程序运行中后来的异常信息则不再添加分割线。如果你有其他的配置能解决这个问题或其他想法欢迎在下方留言一起讨论、学习！ 初始化程序在程序最开始的时候加入： 1log4net.Config.XmlConfigurator.Configure(); 项目用的是 ASP.MVC ，所以添加在了 Global.asax 文件中的 Appliction_Start() 方法中。 编写此行代码需要引入 log4net 的命名空间 using log4net; 打印日志信息基本使用在需要打印日志的地方添加： 1LogManager.GetLogger(typeof(Program)).Debug(\"信息\"); 通过 LogManager.GetLogger 传递需要记录的日志类名获得这个类的 ILog （这样在日志文件中就能看到这条日志是哪个类输出的了），然后调用 Debug 方法输出消息。因为一个类内部不止一个地方要打印日志，所以 一般把 ILog 声明为一个 static 字段： 1Private static ILog logger = LogManager.GetLogger(typeof(Test)) 输出错误消息用 ILog.Error 方法，第二个参数可以传递 Exception 对象，如： log.Error(&quot;***错误&quot;+ex)、log.Error(&quot;***错误&quot;,ex) 生产者——消费者模式上面基本使用有一个问题，如果是网站类或大型系统，是很多人同一时间点进行使用，但是每次写入文件的日志信息可能就会有很多条，同一时间内多条日志同时写入文本就会造成 文件并发 问题。这里通过队列的方式来记录日志。 思路：把所有产生的日志信息存放到一个队列里面，然后通过新建一个线程不断的从这个队列里面读取异常信息，然后往日志文件里面写。这个时候就不用担心多个日志信息同时写入日志文件引起的文件并发问题，这就是所谓的生产者——消费者模式。 新建异常信息监控类新建一个类 MyErrorAttribute ，继承自全局异常类 HandleErrorAttribute。 12345678910111213141516171819202122using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.Mvc;namespace SpringLog4netDemo.Models&#123; public class MyErrorAttribute:HandleErrorAttribute &#123; //创建静态队列 public static Queue&lt;Exception&gt; ExceptionQueue = new Queue&lt;Exception&gt;(); public override void OnException(ExceptionContext filterContext) &#123; //将异常信息写入队列中 ExceptionQueue.Enqueue(filterContext.Exception); base.OnException(filterContext); &#125; &#125;&#125; 这样做的目的是通过修改全局异常类拿到触发异常的信息，存储到我们准备好的队列中，用于后面的存储。 在 FilterConfig 类中注册自己的异常信息监控类123456789101112131415using System.Web;using System.Web.Mvc;using SpringLog4netDemo.Models;namespace SpringLog4netDemo&#123; public class FilterConfig &#123; public static void RegisterGlobalFilters(GlobalFilterCollection filters) &#123; // filters.Add(new HandleErrorAttribute()); filters.Add(new MyErrorAttribute()); &#125; &#125;&#125; 在 App_Start 文件夹下 有三个类 ，修改其中的 FilterConfig.cs ，将我们自己写的异常信息监控类注入。 在程序入口添加线程监控在 Global.asax 文件中的 Application_Start() 方法中添加一个线程，用于监控程序运行过程中是否有异常发生。 12345678910111213141516171819202122232425//新建线程用以检测日志ThreadPool.QueueUserWorkItem(o =&gt;&#123; while (true) &#123; if (MyErrorAttribute.ExceptionQueue.Count &gt; 0) &#123; Exception ex = MyErrorAttribute.ExceptionQueue.Dequeue(); if (ex != null) &#123; ILog logger = LogManager.GetLogger(&quot;ErrorMsg&quot;); logger.Error(ex.ToString()); &#125; else &#123; Thread.Sleep(500); &#125; &#125; else &#123; Thread.Sleep(500); &#125; &#125;&#125;); 添加引发异常的方法进行测试在控制器 Home 中故意添加一个引发一场的 Action 的方法 TestLog 进行测试。 1234567public ActionResult TestLog() &#123; int a = 5; int b = 0; int c = a / b; return View(); &#125; 在浏览器进行测试： 打开项目所在目录下的 App_Data文件夹 打开项目所在目录下的 App_Data文件夹，可以看到已经有一个日志文件了： 打开该文件可以看到日志信息已经保存进去 需要注意的地方在浏览器直接请求http://localhost:5252/home/testlog 时，VS会报错暂停，这个时候程序已经中断，但是还并未走到我们新注册的异常信息监控类里面的方法，也就是说异常信息还并未存到队列并且并未存储到本地。 此时VS的页面是这样的： 这个时候不要勾选 “SpringLog4netDemo.dll” 前面的选择框，勾选的话以后在此项目中的此类异常都会被VS屏蔽不再显示，在单独测试 Log4Net 的项目中，这个无所谓，但是如果是比较大的项目的话，这样就比较麻烦了，这个时候直接点击 继续 就可以继续运行了，或者有兴趣的话可以执行下一步查看程序执行的流程。 如果手滑点到那里了怎么办呢？ 打开 调试 &gt; 窗口 &gt; 异常设置 &gt; 选中全部选项 &gt; 检查所有选项中是否有屏蔽条件 &gt; 删除屏蔽条件 Log4Net相关概念Log4Net 有3个重要的组件：loggers , appenders 和 layouts 。这3个组件协同工作使得开发者能够根据信息类型和级别（Level）记录信息，以及在运行时控制信息的格式化和信息的写入位置（如：控制台、文件、内存、数据库等）过滤器帮助这些组件控制追加器 （appender）的行为和把对象转化成字符串的对象渲染。 Appender：可以寄那个日志输出到不同的地方，不同的输出目标对应不同的 Appender，如 RollingFileAppender（滚动文件）、AdoNetAppender（数据库）、SmtpAppender（邮件）等。 level（级别）：标识这条日志信息的重要级别。None &gt; Fatal &gt; ERROR &gt; WARN &gt; DEBUG &gt; INFO &gt;ALL ，设定一个 Level ，那么低于这个 Level 的日志是不会被写入到 Appender 中的。 Log4Net 还可以设定多个 Appender，可以实现同时将日志记录到文件、数据库、发送邮件等；可以设定不同Appdener 的不同 level ，可以实现普通级别都记录到文件、ERROR以上级别都发送邮件；可以实现对不同的类设定不同的 Appender；还可以自定义 Appender ，自己实现将 ERROR 信息发送短信等。 日志框架除了 Log4Net 外，还有 Enterprise Libray 中的 Logging Application Block、Apache 的 CommonLog 以及 NLog 等，使用起来都差不多。 最后附上 Log4Net 的官方文档链接 Apache 官方文档——配置","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://liruisen.github.io/categories/ASP-NET/"},{"name":"MVC","slug":"ASP-NET/MVC","permalink":"https://liruisen.github.io/categories/ASP-NET/MVC/"}],"tags":[{"name":"log4net","slug":"log4net","permalink":"https://liruisen.github.io/tags/log4net/"},{"name":"mvc","slug":"mvc","permalink":"https://liruisen.github.io/tags/mvc/"}]},{"title":":Vue与其他操作DOM的第三方库搭配使用","slug":"Vue与其他操作DOM的第三方库搭配使用","date":"2018-01-17T03:14:10.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2018/01/17/Vue与其他操作DOM的第三方库搭配使用/","link":"","permalink":"https://liruisen.github.io/2018/01/17/Vue与其他操作DOM的第三方库搭配使用/","excerpt":"","text":"本次环境为直接引用 Vue.js（开发版） , 没有使用脚手架 Vue 的核心思想是数据驱动 DOM，也建议我们避免直接去进行 DOM 操作，但是在很多业务里，避免不了去使用一些第三方的库，比如 popper.js、swiper.js 等，这些基于原生 JavaScript 的库都有创建和更新及销毁的完整生命周期，如果与 Vue 搭配使用的话，不可避免的会出现直接操作 DOM 的现象，这个时候需要合理的利用一些 Vue 的机制 : $nextTick 使用场景先来看一个简单的demo 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;div id=\"div\" v-if=\"showDiv\"&gt;这是一段文本&lt;/div&gt; &lt;button @click=\"getText\"&gt;获取Div内容&lt;/button&gt;&lt;/div&gt;&lt;script&gt;var app=new Vue(&#123; el:\"#app\", data:&#123; showDiv:false &#125;, methods:&#123; getText:function()&#123; this.showDiv=true; var text=document.getElementById('div').innerHTML; console.log(text); &#125; &#125;&#125;)&lt;/script&gt; 很简单的一段代码：有一个 div ，默认使用 v-if 进行隐藏，点击按钮后，改变 v-if的值，将 div 的值显示出来，同时拿到这个值，输出到控制台上。 按照正常的思路，如果 v-if 的值是 false，直接去获取 div 的内容是获取不到的，因为此时 div 还未被创建，那么应该在点击按钮后，改变 v-if 的值为 true ，div 才会被创建，此时才能被获取到。 但是按照这种思路，控制台会抛出一个异常： Cannot read property &#39;innerHTML&#39; of null 意思是获取不到 div 元素。 异步更新队列按我们正常的思路来说上述代码应该是可以获取到 div 的，但是在实际运行过程中并未能获取到，这里面就涉及到 Vue 一个重要的概念：异步更新队列 Vue 在观察到数据变化时，并不是直接更新 DOM ，而是开启一个队列，并缓冲在同一事件循环过程中发生的所有数据改变，在缓冲时会去除重复数据，从而避免不必要的计算和 DOM 操作。然后，在下一个事件循环 tick 中，Vue 刷新队列并执行实际（已去重的）工作。举个例子来说，如果使用 for 循环来动态改变数据 100 次，其实 Vue 只会应用最后一次改变，如果没有这种机制的话，DOM 就要重绘 100 次，这是一个很大的开销。 关于队列，Vue 会根据当前浏览器环境优先使用 Promise.then 和 MutationObserver ，如果都不支持，就会使用 setTimeout 代替。 解决方法知道 Vue 异步更新 DOM 的原理后，上面的报错应该就很容易理解了。在执行 this.showDiv=true; 时，div 仍然没有被创建出来，直到下一个 Vue 事件循环时，才开始创建。 如果引用了其他的第三方库，需要立即创建、立即获取，这个时候就需要避开 Vue 的这种机制了，$nextTick 就是用来指导什么时候 DOM 更新完成的，所以上面的代码需要进行修改：123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;div id=\"div\" v-if=\"showDiv\"&gt;这是一段文本&lt;/div&gt; &lt;button @click=\"getText\"&gt;获取Div内容&lt;/button&gt;&lt;/div&gt;&lt;script&gt;var app=new Vue(&#123; el:\"#app\", data:&#123; showDiv:false &#125;, methods:&#123; getText:function()&#123; this.showDiv=true; //update begin this.$nextTick(function()&#123; var text=document.getElementById('div').innerHTML; console.log(text); &#125;) //update end &#125; &#125;&#125;)&lt;/script&gt; 这时再点击按钮，控制台就会打印出 div 的内容：这是一段文本 。","categories":[{"name":"前端","slug":"前端","permalink":"https://liruisen.github.io/categories/前端/"},{"name":"Vue","slug":"前端/Vue","permalink":"https://liruisen.github.io/categories/前端/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://liruisen.github.io/tags/Vue/"}]},{"title":"Spring.Net使用","slug":"Spring-Net使用","date":"2017-11-25T06:20:06.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2017/11/25/Spring-Net使用/","link":"","permalink":"https://liruisen.github.io/2017/11/25/Spring-Net使用/","excerpt":"","text":"一、Spring.NET 简单使用 最近用到了 Spring.NET ,不过在第一次使用的时候就遇到了一些问题，打算整理成系列博客，不断的总结和分享。 1. 什么是 Spring.NET ?Spring 框架本是 Java 平台上一个应用非常多的、开源的框架。虽然语言是固定的，但是好的方法应该是通用的，于是 Spring 框架 就被程序员从 Java 平台搬迁到了 .NET 平台。 通过Spring.NET，我们可以用统一且透明的方式来配置应用程序。Spring.NET 的重点是为中间层提供声明式事务管理，以及一个功能齐全的 ASP.NET 扩展框架。Spring.NET 是非侵入式的，代码对框架本身不会产生任何依赖。 Spring.NET 能够提供很多方面的功能，例如：控制反转（英文缩写为IoC）、依赖注入（DI）、面向方面编程(AOP)、数据访问抽象, 以及 ASP.NET 集成等。 Spring.NET 核心： Spring.Core 库是框架的基础, 提供依赖注入功能。Spring NET中大多数类库依赖或扩展了Spring.Core的功能。IObjectFactory接口提供了一个简单而优雅的工厂模式，移除了对单例和一些服务定位stub的必要。允许你将真正的程序逻辑与配置解耦。作为对IObjectFactory 的扩展，IApplicationContext接口也在Spring.Core库中。 2.快速创建第一个使用 Spring.NET 的程序​ 本次开发环境： VS 2017 本次开发项目：.netframework控制台项目 （1）. 使用 Nuget 安装 Spring.core 包 使用 Spring.NET 需要 Spring.Core 库的支持，同时在 Nuget 中安装 Spring.Core 包，会在项目上自动引入相关的引用。 （2）.创建相关文件。 本次创建两个文件：IUserInfo 接口、UserInfo 实体类。使用 Spring 反射创建 UserInfo 类，使用 IUserInfo 接口调用反射创建的类。 1234567891011121314//IUserInfo接口using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Demo&#123; public interface IUserInfo &#123; string ShowMss(); &#125;&#125; 123456789101112131415161718//UserInfo实体类 using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Demo&#123; //实现 IUserInfo接口 public class UserInfo : IUserInfo &#123; public string ShowMss() &#123; return &quot;Hello Spring.NET&quot;; &#125; &#125;&#125; 重要的是在配置节里面的配置 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;!--sectionGroup节点一定要在紧跟着configuration下面第一个添加--&gt; &lt;sectionGroup name=\"spring\"&gt; &lt;!--跟下面Spring.Net节点配置是一一对应关系--&gt; &lt;section name=\"context\" type=\"Spring.Context.Support.ContextHandler,Spring.Core\"/&gt; &lt;section name=\"objects\" type=\"Spring.Context.Support.DefaultSectionHandler,Spring.Core\"/&gt; &lt;/sectionGroup&gt; &lt;/configSections&gt; &lt;!--Spring.Net节点配置--&gt; &lt;spring&gt; &lt;!--容器配置--&gt; &lt;context&gt; &lt;resource uri=\"config://spring/objects\"/&gt; &lt;/context&gt; &lt;objects&gt; &lt;!--objects里面放容器的所有节点--&gt; &lt;description&gt;An example that demonstrates simple Ioc features.&lt;/description&gt;&lt;!--描述--&gt; &lt;!--name 必须要唯一的，type = 类的全名称，所在的程序集--&gt; &lt;object name=\"UserInfo\" type=\"Demo.UserInfo,Demo\"&gt;&lt;/object&gt;&lt;!--咱们刚才创建的UserInfo实体类--&gt; &lt;/objects&gt; &lt;/spring&gt; &lt;startup&gt; &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.6\" /&gt; &lt;/startup&gt;&lt;/configuration&gt; 获取并执行： 1234567891011121314151617181920212223//Program 程序入口类//引用 ： Spring.Context 和 Spring.Context.Support 两个命名空间using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using Spring.Context;using Spring.Context.Support;namespace Demo&#123; class Program &#123; static void Main(string[] args) &#123; IApplicationContext ctx = ContextRegistry.GetContext(); IUserInfo userInfo = (IUserInfo)ctx.GetObject(&quot;UserInfo&quot;); Console.WriteLine(userInfo.ShowMsg()); Console.Read(); &#125; &#125;&#125; 输出结果： 输出结果 注意事项： 必须安装 Spring.core 包，否则缺少环境支持。 需要正确 配置 配置文件： sectionGroup节点一定要在紧跟着configuration下面第一个添加. objects 节点中的 &lt;object&gt;&lt;/object&gt;节点，name=&quot;value&quot; value 值一定要唯一，type =&quot;value1 , value2&quot; 中 value1 是需要反射创建出来的类的全名称，value2 是该类所在的程序集。 反射创建。 二、Spring.NET在MVC中的使用 在ASP.NET MVC中应该如何使用Spring.NET？ 1.先导入dll文件导入以下这些程序节 Spring.core.dll Spring.Web.dll Spring.Web.Extensions.dll Spring.Web.Mvc4.dll Common.Logging.dll 或者直接在 NuGet 中安装 Spring.Web.MVC , 这个方法会直接应用相应的 dll。 2.修改配置信息在大型的项目中，如果把所有的配置信息都放在 Web.config 文件夹，会让该文件显得非常复杂，也不利于维护和修改，这个时候可以将 Spring 的配置节分离到单独的 Xml 文档中。 Web.Config文件相应配置如下 12345678910111213141516171819&lt;configSections&gt; &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt; &lt;section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" requirePermission=\"false\" /&gt; &lt;!--Spring.NET配置节信息--&gt; &lt;sectionGroup name=\"spring\"&gt; &lt;!--Spring.Net配置--&gt; &lt;section name=\"context\" type=\"Spring.Context.Support.MvcContextHandler, Spring.Web.Mvc4\"/&gt; &lt;/sectionGroup&gt; &lt;!--Spring.NET配置节信息END--&gt; &lt;/configSections&gt; &lt;!--Spring配置信息--&gt; &lt;spring&gt; &lt;!--Spring.Net配置--&gt; &lt;context&gt; &lt;resource uri=\"file://~/Config/controllers.xml\"/&gt; &lt;resource uri=\"file://~/Config/services.xml\"/&gt; &lt;/context&gt; &lt;/spring&gt; &lt;!--Spring配置信息End--&gt; 3.准备分离出来的文件在 Web 项目下新建一个名叫 Config 的文件夹，里面存放 Spring的 配置信息节。 需要注意的是，该文件夹里面的 Xml 文件的复制到输出目录属性需要修改为始终复制。这样做的原因是因为这个Xml文件是静态文件，项目生成解决方案的时候默认是不加载的，只有始终复制才会每次生成的时候加载到 Debug文件夹内。 4.修改controllers.xml中的配置信息在 controllers.xml 文件中，根节点为 Objects 节点， 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;objects xmlns=\"http://www.springframework.net\"&gt; &lt;object type=\"LRS.OA.Web.Controllers.UserInfoController,LRS.OA.Web\" singleton=\"false\"&gt; &lt;property name=\"UserInfoService\" ref=\"UserInfoService\"/&gt; &lt;/object&gt;&lt;/objects&gt; type : 容器内的对象所在的位置（命名空间.类） singleton ：是否指定单例模式，默认是单例模式 propeerty : DI 注入的属性 ref : propeerty 节的属性，指向的是创建的&lt;object&gt;节点名称，也就是创建的其他的对象节点 services.xml 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;objects xmlns=\"http://www.springframework.net\"&gt; &lt;object name=\"UserInfoService\" type=\"LRS.OA.BLL.UserInfoService,LRS.OA.BLL\" singleton=\"false\"&gt; &lt;/object&gt;&lt;/objects&gt; ### ６.修改Global文件 将 MVCApplication 继承自 SpringMvcApplication 。 三、Ioc 和 DIIoc 是控制反转，目的是将实例化类这一步骤从代码中取出，让容器完成自动完成该操作。 DI是依赖注入，是容器在实例化对象时，将该实例的指定属性赋上指定的值。","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://liruisen.github.io/categories/ASP-NET/"},{"name":"MVC","slug":"ASP-NET/MVC","permalink":"https://liruisen.github.io/categories/ASP-NET/MVC/"}],"tags":[{"name":"Spring.Net","slug":"Spring-Net","permalink":"https://liruisen.github.io/tags/Spring-Net/"},{"name":"MVC","slug":"MVC","permalink":"https://liruisen.github.io/tags/MVC/"}]},{"title":"配置Git","slug":"配置Git","date":"2017-11-06T03:43:04.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2017/11/06/配置Git/","link":"","permalink":"https://liruisen.github.io/2017/11/06/配置Git/","excerpt":"","text":"配置Git 换了电脑，但是新电脑上面并没有安装Git，重新安装后需要进行密钥和用户配置，虽然就没几行命令，但是每次去百度搜索还是费心，写成博客，以后直接找自己写的。 设置user.name和user.email信息：12git config --global user.name \"你的GitHub用户名\"git config --global user.email \"你的GitHub注册邮箱\" 生成密钥文件：1ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" 回车默认不需要设置密码。 把生成的密钥添加到Github上 找到 .ssh 文件夹内的 id_rsa.pub 文件 通常文件目录为 C:\\Users\\Administrator\\.ssh ,用记事本打开 id_rsa.pub 文件，复制文件中的全部内容到剪切板。 把密钥复制到 Github 的配置上 检测Github上的ssh密钥是否添加成功：1ssh git@github.com Git下载地址 (官网下载太慢，这是腾讯软件中心的下载链接) Git学习链接： 廖雪峰Git教程 stormzhang Git系列教程","categories":[{"name":"Git教程","slug":"Git教程","permalink":"https://liruisen.github.io/categories/Git教程/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://liruisen.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://liruisen.github.io/tags/Github/"}]},{"title":"Hexo发布文章","slug":"Hexo发布文章","date":"2017-11-04T06:43:04.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2017/11/04/Hexo发布文章/","link":"","permalink":"https://liruisen.github.io/2017/11/04/Hexo发布文章/","excerpt":"","text":"前面咱们已经搭建好了Hexo博客，并成功发布到了Github上面，但是怎么才能把新写的文章发布上去呢？ 创建新文章方法1：进入你的博客目录，在 /source/_posts 文件夹下直接建立一个.md文件。 需要注意的是，文件内容的开头有固定的格式： 12345---title: Hexo发布文章date: 2018-11-03 19:52:39tags:Hexo--- title 是文章的标题 date 是文章的发布时间 tags 是文章的标签 后面写正文就可以了！ 方法2：进入博客目录，使用 Git Bash Here 命令窗口，或者 Windows 自带的 CMD 命令窗口，输入下面命令 1hexo new &quot;新建文章名称&quot; 这样就会在 /source/_posts 文件夹下，新建好一个 .md 文件，同时该文件中的头部信息 （title、data、tags）也会给你默认生成，后面接着写正文就可以了 。 发布文章新文章写好了，但是直接启动 hexo 博客或直接访问托管的 Github 平台的话，会发现并没有写好的文章，这是因为写好的文章现在并没有被 hexo引擎解析，同时也没有推送到 Github 上生成。 在该博客项目文件夹下进入命令行窗口 Git Bash Here 和 CMD 都可以。 输入命令： 12hexo generatehexo deploy hexo generate : 生成修改 hexo deploy ：将生成的修改部署到 Github 上 注意 部署到GitHub时，可能因为网速、被墙等原因，需要多次运行 hexo deploy ；有时候可以运行 hexo clean 后在运行上述代码。 .md 文件不要用记事本打开，建议使用具有 markdown语法的程序打开，比如：Typora 、subline text、notepad++ 等，也可以使用在线 markdown 编辑器 。","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://liruisen.github.io/categories/Hexo教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liruisen.github.io/tags/Hexo/"}]},{"title":"Hexo + Github pages搭建私人博客","slug":"Hexo-Github-pages搭建私人博客","date":"2017-11-03T02:43:04.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2017/11/03/Hexo-Github-pages搭建私人博客/","link":"","permalink":"https://liruisen.github.io/2017/11/03/Hexo-Github-pages搭建私人博客/","excerpt":"","text":"最近因为开始喜欢上使用 Markdown 语法来写博客，主要是因为现在各个博客网站对 Markdown 语法的支持越来越好了，本地写好一份文件，到各大博客复制粘贴即可，省去了博客搬家和手动调样式的烦恼，不会 Markdown 语法之前觉得这是什么沙雕玩意儿，现在是真香。 后来偶然想到，Github好像对 MarkDown 的支持也不错，我可以把写的博客源文件放在 Github 上备份一份啊！说干就干，专门开了一个仓库去保存博客源文件。前几篇写的挺舒服的，后来发现了一个问题，样式不好看，，，那啥，温饱之后开始追求精神需求量，哈哈哈哈哈，这个时候想起以前以为大佬好像提过可以在GIthub上写博客，我想，大佬的思想应该不会像我这么咸鱼吧，果不其然，还真让我找到了在 Github 上部署博客的方法，重点是还不用使用私人服务器和域名！！！真是发现新大陆了！！！撸起袖子加油干！！ 为什么要创建私人博客？我觉得现在身为互联网时代，有自己的个人网站其实就和有自己名片差不多，在这可以不断的记录自己的生活，总结知识，人生思考什么的。 同时对于码农来说，有自己的私人网站，有详细个人的博客，无疑会在自己工作或找工作的过程中提供帮助。 再者就是相对的自由了，现在市面上有很多的Blog系统，只要注册就可以直接在他们平台上生成一个自己的Blog，虽然省去了很多麻烦的步骤，但是命运赠送的一切欢愉，背后早已为其准备好了相应的痛苦：乱七八糟不停滚动的广告（CSXN）、简陋的UI（BoXYuan）……更不爽的就是，必须受到他们的限制与监管，只要擦边就删你文章。比如这样： 所以搞一个完全属于自己的网站，相对来说，没那么苦逼。 Github pages + Hexo 搭建博客什么是 Github pages ？详情点击 百度 ,那什么又是 Hexo 呢 ，详情还请点击 Hexo 。 安装 Git 和 Node.js因为最终我们是需要将博客部署在 Github 上面的（免费空间，不需要域名），所以需要安装 Git 工具，用于把我们的博客推送到 Github 上面（当然，只是为了保持与 Github 上面的仓库保持联系的话 Github Desktop 也是一个不错的工具，还免去了每次换电脑之后更换 shh 公钥的麻烦），因为 Hexo 是基于 Node.js 的，所以我们也需要安装 Node.js 。 Git下载地址 、 Node.js下载地址 关于二者的安装，一路 Next 下去就好了，建议装在 C 盘，环境类型相关的应用，装在其他盘里容易出问题。 检查安装是否成功 当Git 安装完毕后，Git Bash Here 和 Git GUI Here 应该已经集成在了鼠标右键中了。 右键进入 Git Bash Here进入命令行页面，输入 1node -v 如果可以看到 Node.js 的版本号，则证明已经安装成功。 安装 Hexo在任何地方，打开 Git Bash Here（Dos命令行也是可以的） 输入： 1npm install hexo-cli -g","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"https://liruisen.github.io/categories/Hexo教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liruisen.github.io/tags/Hexo/"}]},{"title":"EF使用MySQL","slug":"EF使用MySQL","date":"2017-10-11T08:58:13.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2017/10/11/EF使用MySQL/","link":"","permalink":"https://liruisen.github.io/2017/10/11/EF使用MySQL/","excerpt":"","text":"新项目需要使用MVC+EF+MySQL，以前使用的数据库都是微软的亲儿子SQL Server，所以在使用的时候基本没有遇到过什么问题，但是这次在使用MySQL的时候却一直出现问题，看到的博客很多，千篇一律还没能解决问题，整理此博客，用以记录与分享 EF如何使用SQL Server作为数据源不再多说，不太了解的话查看此博客，下面将讲述EF如何使用MySQL ，本次开发环境为 VS2017，MySQL版本为：MySQL5.5（影响不大） [TOC] 1.配置环境添加实体数据模型在项目 &gt; 添加 &gt; 新建项 &gt; 数据 &gt; ADO.NET实体数据模型 &gt; 添加 &gt; 从数据生成 &gt; 新建连接 选择数据源 在这里可以看到，并没有MySQL的数据源。这是因为没有安装MySQL与VS的集成组件下载地址和MySQL连接组件下载地址，安装完毕后就有了。 在这里插入图片描述 2.使用Nuget 安装 MySQL.Data.Entity 和 MySQL.Data划重点,这里容易出问题常见问题 (1) .闪退在上一步，安装完 mysql-connector-net 组件 和 mysql-for-visualstudio 组件后，虽然在VS上出现了 MySQL Database 选项，但是如果直接点击继续的话，会出现闪退。这是因为没有在Nuget中安装 MySQL.Data.Entity 和 MySQL.Data 这两个包。 如同在使用 SQL Server 作为数据源的时候，需要在 Nuget 中安装 EntityFramwork 包，才能正常创建ADO.NET实体数据模型，这里也是一样，如果不安装 MySQL.Data.Entity 和 MySQL.Data 这两个包，同样无法创建以 MySQL 为数据源的 ADO.NET 实体数据模型。 (2) .您的项目引用了最新实体框架；但是，找不到数据链接所需的与版本兼容的实体框架数据库提供程序……上面在Nuget中，安装过 MySQL.Data.Entity 和 MySQL.Data 这两个包后，应该就可以进入下一步了，但是这里面可能还会遇到另外一个问题 您的项目引用了最新实体框架；但是，找不到数据链接所需的与版本兼容的实体框架数据库提供程序…… 如图所示： 您的项目引用了最新实体框架；但是，找不到数据链接所需的与版本兼容的实体框架数据库提供程序 这个问题困扰了我很久，在网上找到了很多关于这个问题的博客，虽然博主都给了解决方案，但是我使用那些解决方案并没有能很好的解决问题，最后找到了其他的、更简单的解决方案解决了问题。 大家还记得前面安装的 mysql-connector-net 组件 吗， MySQL官网上这个组件的版本最新的是 8.0.12，但是 VS2017 的 Nuget 包管理器中 MySQL.Data.Entity 稳定版最新版本为6.10.8 MySQL.Data稳定版最新版本为 8.0.12 ，出现上面的报错，就是因为这三者版本不一致,三者版本必须一致 ，否则就会报这个错误！ 三者版本 可以先添加指定版本的 MySQL.Data.Entity 这样会自动添加上对应版本的 MySQL.Data 这样就可以顺利创建 ADO.NET实体数据模型了 在这里插入图片描述 (3) .上述三者版本一致，但是仍然不能正常创建检查项目的 .netframwork 版本，不同的 MySQL.Data.Entity 版本有不同的 .netframwork 最低版本支持，在 packages 文件夹或 Nuget 中查看所需支持的最低 .netframwork 版本，检测所建项目的 .netframwork 版本是否符合要求。 (4) 给定关键字不在字典中 这个问题开始并没有碰到，一切正常，不过后来在别人电脑上操作，上午创建一切正常，但是下午就出现了这个问题，然后就一直无法创建，在CSDN上发现了一篇博客，解决了问题，后面为参考博客原文： ——————————————————————参考博客——————————————————————— 导致这个问题的原因有很多，比如数据库编码不一致、mysql connector的版本不一致等等 解决办法： 1.确报VS中使用的MySQL版本（NuGet获取相应即可）与当前电脑安装的Mysql Connector版本一致； 2.关闭VS ，在系统盘中找到文件 DefaultView.SEView 并删除。 通常路径为：用户\\AppData\\Microsoft\\VisualStudio\\xx\\ServerExplorer 参考原文链接：https://blog.csdn.net/iceagezh/article/details/78924154 ——————————————————————参考博客End————————————————————— 我使用的是第二种方案解决的问题，因为前面三者的版本都一致，不过 DefaultView.SEView 这个文件并不是很好找，根据博主给的地址没有找到，我使用的是 Everything 软件找到的这个文件，并删除，找到了2个这个文件，都删除了，通过删除后的VS的状态，怀疑这个文件是用来保存每次连接数据库的信息文件，因为删除过这个文件后曾经在VS中使用EF连接数据库的账号密码都清空了，不过已经能正常创建 ADO.NET 实体数据模型了。 总结这次遇到了不少的问题，但是本质上来说也算不上是特别严重的问题，VS2017是真的好用，微软对亲儿子和其他人家的儿子态度真是不同！下面是问题解决总结： 安装 mysql-connector-net 组件 和 mysql-for-visualstudio 组件，mysql-for-visualstudio 组件无版本要求，但是 mysql-connector-net 组件需要与后面在 Nuget 中引用的 MySQL.Data.Entity 和 MySQL.Data 版本一致。如果不安装这两个组件，在选择数据源的时候不会出现MySQL Database选项 “引用了最新的实体框架，但是找不到数据链接所需的与版本兼容的实体框架数据库提供程序…”，检查 mysql-connector-net 组件、 MySQL.Data.Entity 包、MySQL.Data 包，三者的版本是否一致 不能引用 MySQL.Data.Entity 包、MySQL.Data 包，检查项目的 .netframework 版本是否满足这两个包的最低版本需求。 “给定关键字不在字典中”，关闭VS，找到并删除 DefaultView.SEView 文件。","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://liruisen.github.io/categories/ASP-NET/"},{"name":"MVC","slug":"ASP-NET/MVC","permalink":"https://liruisen.github.io/categories/ASP-NET/MVC/"}],"tags":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://liruisen.github.io/tags/ASP-NET-MVC/"},{"name":"EF","slug":"EF","permalink":"https://liruisen.github.io/tags/EF/"},{"name":"MySQL","slug":"MySQL","permalink":"https://liruisen.github.io/tags/MySQL/"}]},{"title":"EF框架使用","slug":"EF框架","date":"2017-08-11T08:58:13.000Z","updated":"2019-05-20T13:49:55.301Z","comments":true,"path":"2017/08/11/EF框架/","link":"","permalink":"https://liruisen.github.io/2017/08/11/EF框架/","excerpt":"","text":"本博客所有案例的开发环境为 VS2013 + SQL Server 2012 Entity Framework实体框架简介Entity Framework 实体框架（EF）是ADO.NET的开源对象关系映射（ORM）框架，它是 .NET Framework 的一部分，是一组支持开发面向数据的软件应用程序的技术。微软为实现 .NET 跨平台，将 EF 从 .NET 分离，使EF更加组件化。2016年6月27日，Entity Framework 7作为实体框架核心 1.0 发布，与 ASP.Net Core 1.0 和 .Net Core 1.0 一起发布，重命名为凸显出它是完全重新而不是增量升级，同时，EF7并不会取代EF6。 在EF中的实体数据模型（EDM）由以下三种模型和具有相应文件扩展名的映射文件进行定义。概念架构定义语言文件（.csdl）——定义概念模型存储架构定义语言文件（.ssdl）——定义存储模型映射规范语言文件（.msl）——定义存储模型与概念模型之间的映射M。 实体框架 使用这些基于XML的模型和映射文件将对概念模型中的实体和关系的创建、读取、更新、和删除操作转换为数据源中的等效操作。EDM 甚至支持将概念模型中的实体映射到数据源中的存储过程。 ORM（Object Relational Mapping）框架采用元数据来描述对象一关系映射细节，元数据一般采用XML格式，并且存放在专门的对象一映射文件中。 广义上来说，ORM 可以被认为是 面向对象模型和关系型数据库的数据结构之间的相互转换。 狭义上来说，ORM 可以被认为是，基于关系型数据库的数据存储，实现了一个虚拟的面向对象的数据访问接口。理想情况下，基于这样一个面对对象的接口，持续化一个OO对象应该不需要了解任何关系型数据库存储数据的实现细节。 其他.NET ORM框架: PetaPoco : 与完备的 ORM 框架不同，PetaPoco 更加注重易用性和性能。使用 PataPoco 只需要引入一个C#文件，可以使用强类型的 POCO（Plain Old CLR Object）,并支持 T4 模板生成的类等。此外，由于 PetaPoco 是开源项目，因此添加条件来处理如空间数据等特定情况会很容易。 Dapper :性能方面高于 PetaPoco，速度只稍逊于手工编码的数据访问层（DAL、Data AccessLayer），还有一些对初学者会有帮助的、位于官网上的系列博文和一些独立博文教程。 一、DataFirst使用EF，创建Model （DataFirst） 在解决方案中，创建所使用的项目。例如：ASP网站项目、WinForm窗体项目…… 在新建的项目中，添加 &gt; 新建项 &gt; 数据 &gt; ADO.NET实体数据模型（.edmx） 在新建的.edmx中选择：从数据库生成（DatabaseFirst） 选择新建连接，填写连接数据库 &gt; 填写登录数据库信息 &gt; 选择或输入需要生成模型的数据库名称. 选择需要创建模型的表、视图、存储过程 点击下一步，直接生成（有些电脑可能会出现警告信息，忽视即可）。 ​ （图片不清晰的话请在：浏览器上，鼠标右键，在新标签页中打开图片。即可看到清晰图片） 使用EF创建的内容创建完成后，项目会默认引入两个命名空间：EntityFramework、System.Data.Entity 最外层为.edmx文件，EF模型设计器，展示从数据库创建的模型，包括：表名、属性（表字段）、导航属性（外键、表与表之间的对应关系）、表与表之间1对1、1对多的关系。 Model1.Context.tt、Model.Designer.cs、Model.edmx.diagram、Model1.tt Model1.Context.tt：包含Model1.Context.cs。Model1.Context.tt由T4模板生成，不可更改，Model1.Context.cs继承自DbContext，包括构造方法（继承自父类的构造方法，并在此传递配置文件的数据库连接字符串）、各个表所对应的Dbset&lt;T&gt;类型的自动属性。 Model.Designer.cs：自动生成，无需更改 Model.edmx.diagram：描述edmx文件的元素信息（名称、位置……） Model1.tt：包含生成的Model.cs，自身由T4模板生成，无需修改 使用EF进行增删改查查询123456789StudentMISEntities stu = new StudentMISEntities();//IQueryable&lt;Users&gt; userInfoList=from u in stu.Usersvar userInfoList = from u in stu.Users where u.id == 10 select u;foreach (var item in userInfoList)//EF延迟加载机制，数据用到的时候才去数据库中查询，不用的时候不去查询，提高程序性能&#123; Response.Write(item.uName);&#125; 增加1234567Users userInfo = new Users();userInfo.uName = \"2333\";userInfo.uPassword = \"123\";userInfo.uRole = \"学生\";StudentMISEntities stu = new StudentMISEntities();//创建EF数据操作类实例stu.Users.Add(userInfo);//把数据添加到EF，并添加标记stu.SaveChanges();//把数据保存到数据库 修改12345678910111213141516StudentMISEntities stu = new StudentMISEntities();var userInfoList = from u in stu.Users where u.id == 16 select u;Users userInfo = userInfoList.FirstOrDefault();//返回第一个元素，如果没有的话，返回nullif (userInfo!=null)&#123; userInfo.uPassword = \"12345678\"; stu.Entry&lt;Users&gt;(userInfo).State = System.Data.Entity.EntityState.Modified;//添加修改标记 stu.SaveChanges(); Response.Write(userInfo.uPassword);&#125;else&#123; Response.Write(\"要修改的数据不存在\");&#125; 删除12345678910111213141516 StudentMISEntities stu = new StudentMISEntities(); var userInfoList = from u in stu.Users where u.id == 17 select u;Users userInfo = userInfoList.FirstOrDefault();//返回第一个元素，如果没有的话，返回nullif (userInfo!=null)&#123; //stu.Users.Remove(userInfo); stu.Entry&lt;Users&gt;(userInfo).State = System.Data.Entity.EntityState.Deleted;//添加删除标记 stu.SaveChanges(); Response.Write(\"已删除\");&#125;else&#123; Response.Write(\"要删除的数据不存在\");&#125; 二、ModelFirst 除了支持 DatabaseFirst 外，EF 还支持 ModelFirst 、 CodeFirst，这两种类型不同于DatabaseFirst 先建立好数据库而后映射 Model ， ModelFirst 是通过 Model 映射创建数据库，而 CodeFirst 类似于 ModelFirst， 通过代码逻辑自行创建 Model 并映射数据库，但是不同于 ModelFirst 由 VS 自动创建。 Model先行，通过Model创建数据库 步骤： 在新建的项目中，添加 &gt; 新建项 &gt; 数据 &gt; ADO.NET实体数据模型（.edmx） 在新建的.edmx中选择：空模型（ModelFirst） 在.edmx图形化窗口中，右键 &gt; 新增 &gt; 实体 在新增实体页面 填写: 实体名（表名）、是否创建键属性（是否创建主键）、属性名称、属性类型 &gt; 确定 在.edmx图形化窗口中，在 实体 上右键 &gt; 新增 &gt; 标量属性（表字段） 选中标量属性，按快捷键 F4 或调出属性面板，可以更改标量属性的：类型、名称、长度（必改） 在多个实体，且实体之间有关联的时候，在.edmx图形化设计页面中，右键 &gt; 新建 &gt; 关联 在添加关联页面设置内容（默认即可） 在所有模型创建完毕，在.edmx页面 右键 &gt; 根据模型生成数据库 在 “生成数据库 向导” 页面，新建数据库连接 &gt; 设置连接字符串 &gt; 选择需要创建表的数据库 &gt; 点击下一步 生成数据库向导中，会生成 DDL（数据库设计语言），并另存为 .sql 文件 生成 .sql 文件后，建立的Model并没有映射到数据库引擎中，需要在 .sql 文件中，右键 &gt; 执行，即可。 ​ （图片不清晰的话请在：浏览器上，鼠标右键，在新标签页中打开图片。即可看到清晰图片） 注意事项： 新建 标量属性 后，需要在属性面板对 标量属性的 长度 和 数据类型 进行限制，string 长度即为数据库内字段的 NVarChar 的长度 。 在 .edmx 图形化页面 新建完实体 后，解决方案里面可能没有生成 Model.tt 文件（包含 Model 模型.cs），这时候在 .edmx 图形化页面: 右键 &gt; 添加代码生成项 &gt; 数据 &gt;EF 版本.x DbContext 生成器 &gt; 确定 关于实体更新 需映射数据库更新 更新实体后，VS 在生成的DDL数据库脚本中，是把原先创建好的表全部删除，再重新创建更新后的实体所对应的表，如果原数据表中存在数据，数据也会一并删除。（2）. 在更新数据库时一定要谨慎，做好数据库备份，同时如果只是小的改动（扩大字符长度），手动在数据库里 修改即可，或者仅把更新的sql脚本部分拷贝出来，复制到SQL Server执行 三、CodeFirst先写代码，通过代码创建实体，映射数据库 步骤： 新建项目，在项目里面通过 NuGet程序包 安装EntityFramework（该操作会自动引入EntityFramework以及相对应的命名空间） 在配置文件里面添加连接字符串 123&lt;connectionStrings&gt; &lt;add name=\"CodeFirstDemo\" connectionString=\"server=.;uid=用户;pwd=密码;database=Test2\" providerName=\"System.Data.SqlClient\"/&gt; &lt;/connectionStrings&gt; 创建类 .cs ，设置类的属性、类之间的关联 studentInfo 1234567891011121314151617using System;using System.Collections.Generic;using System.Linq;using System.Web;namespace CodeFirstDemo&#123; public class StudentInfo &#123; public int Id &#123; get; set; &#125; public string stuName &#123; get; set; &#125; public DateTime subTime &#123; get; set; &#125; //建立联系 public virtual ClassInfo classInfo &#123; get; set; &#125; &#125;&#125; classInfo 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.ComponentModel.DataAnnotations;namespace CodeFirstDemo&#123; public class ClassInfo &#123; //Id添加主键标识 [Key] public int Id &#123; get; set; &#125; //数据类型为NVarChar（32），且不可为空 [StringLength(32)] [Required] public string clsName &#123; get; set; &#125; [Required] public DateTime sbuTime &#123; get; set; &#125; //建立联系 public virtual ICollection&lt;StudentInfo&gt; sutdentInfo &#123; get; set; &#125; &#125;&#125; 创建 EF数据操作类 codeFirstDbcontex 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Data.Entity;using System.Data.Entity.ModelConfiguration.Conventions;namespace CodeFirst&#123; public class codeFirstDbcontext:DbContext &#123; //调用父类的构造方法，并传递 配置文件内的 数据库连接字符串 字段 public codeFirstDbcontext() : base(\"name=connStr\") &#123; &#125; public DbSet&lt;ClassInfo&gt; ClassInfo &#123; get; set; &#125; public DbSet&lt;StudentInfo&gt; Student &#123; get; set; &#125; protected override void OnModelCreating(DbModelBuilder modelBuilder) &#123; //实体模型映射成表的时候执行 //移除 将表名设置为实体类型名称的复数版本的约定 //模型名映射在数据库表的时候，可能会出现复数（s） modelBuilder.Conventions.Remove&lt;PluralizingTableNameConvention&gt;(); &#125; &#125;&#125; 执行 12345678codeFirstDbcontext db = new codeFirstDbcontext();//如果 数据库中不存在库，则创建db.Database.CreateIfNotExists();ClassInfo clsInfo = new ClassInfo();clsInfo.clsName = \"16级.NET班\";clsInfo.sbuTime = DateTime.Now;db.ClassInfo.Add(clsInfo);db.SaveChanges(); image ​ （图片不清晰的话请在：浏览器上，鼠标右键，在新标签页中打开图片。即可看到清晰图片） 四、Linq查询和Lambda查询Linq查询Linq查询全部列并降序12345678var userInfoList = from u in db.Users where u.id &gt; 8 orderby u.id ascending //descending降序 select u;foreach (Users userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; Linq分页12345678910int pageIndex = 3;int pageSize = 3;var userInfoList = (from u in db.Users where u.id &gt; 8 orderby u.id ascending //descending降序 select u).Skip((pageIndex - 1) * pageSize).Take(pageSize);foreach (Users userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; Linq查询部分列12345678var userInfoList = from u in db.Users where u.id &gt; 8 //使用匿名类,设置两个字段UName，UPwd select new &#123; UName = u.uName, UPwd = u.uPassword &#125;;foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.UName+\":\"+userInfo.UPwd+\"&lt;hr/&gt;\"); &#125; Lambda查询过滤筛选12345var userInfoList = db.Users.Where&lt;Users&gt;(u =&gt; u.id &gt; 8);foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; Lambda升序排序排序查询对Id进行升序排序排序 1var userInfoList = db.Users.Where&lt;Users&gt;(U =&gt; true).OrderBy&lt;Users, int&gt;(u =&gt; u.id); 对Id进行降序排序排序 12345var userInfoList = db.Users.Where&lt;Users&gt;(U =&gt; true).OrderByDescending&lt;Users, int&gt;(u =&gt; u.id);foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125; 在以用户名为前提倒序排序的基础上，如果用户名相同，则使用Id作为依据对用户名相同的用户进行倒序排序 1var userInfoList = db.Users.Where&lt;Users&gt;(u =&gt; true).OrderByDescending(u =&gt; u.uName).ThenByDescending&lt;Users,int&gt;(u =&gt; u.id); Lambda分页查询1234567int pageIndex = 3;int pageSize = 2;var userInfoList = db.Users.Where&lt;Users&gt;(U =&gt; true).OrderByDescending&lt;Users, int&gt;(u =&gt; u.id).Skip&lt;Users&gt;((pageIndex-1)*pageSize).Take&lt;Users&gt;(pageSize);foreach (var userInfo in userInfoList)&#123; Response.Write(userInfo.id + \":\" + userInfo.uName + \"&lt;hr/&gt;\");&#125;","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://liruisen.github.io/categories/ASP-NET/"},{"name":"MVC","slug":"ASP-NET/MVC","permalink":"https://liruisen.github.io/categories/ASP-NET/MVC/"}],"tags":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://liruisen.github.io/tags/ASP-NET-MVC/"},{"name":"EF","slug":"EF","permalink":"https://liruisen.github.io/tags/EF/"}]}]}